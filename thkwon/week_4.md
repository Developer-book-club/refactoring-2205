# CH.07 캡슐화

# 7.1 레코드 캡슐화하기

## 중요 내용

- 객체를 사용하면 어떻게 저장 했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다.

## 내 생각

- 단순히 레코드로 두는 것보다, 클래스의 데이터로 둔 상태에서 외부에는 메서드를 제공하는 방식을 설명해주고 있다. 캡슐화의 장점을 설명하는 예제로 잘 이해가 되었다. 단순하게 레코드를 직접 다루어도 되지만 그것보다 캡슐화 처리 했을 때의 장점이 더 잘 드러난 것 같다.

# 7.2 컬렉션 캡슐화하기

## 중요 내용

- 모든 팀원이 원본 모듈 밖에서는 컬렉션을 수정하지 않는 습관을 갖고 있다면 이런 메서드를 제공하는 것만으로도 충분할 수 있다.
- 가장 흔히 사용하는 방식은 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.

## 내 생각

- 여기서는 컬렉션 게터를 제공하는 방법에 대해서 말을 해주는데, 이 부분은 사실 잘 이해가 안되었다. 이 부분은 다른 분들이 어떻게 이해하였는지 문의 드려보고 싶다 → 복제본을 제공해야한다는게 잘 이해가 되지 않음

# 7.3 기본형을 객체로 바꾸기

## 중요 내용

- 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다.
- 시작은 기본형 데이터를 단순히 감싼 것과 큰 차이가 없을 것이라 효과가 미미하다. 하지만 나중에 특별한 동작이 필요해지면 이 클래스에 추가하면 되니 프로그램이 커질수록 점점 유용한 도구가 된다.

## 내 생각

- 나의 경우에도 그냥 매직넘버로 사용되는 코드들이 그룹화가 필요하고, 추가되는 비슷 개념이 있을 때 적극적으로 상수 혹은 Enum으로 처리하려고 하는 편이다 혹은 도메인 로직과 관련된 것이라면, 해당 도메인 관련된 모델의 property, method등으로 리팩토링 해주는 편이다

# 7.4 임시 변수를 질의 함수로 바꾸기

## 중요 내용

- 함수 안에서 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 한다.
- 나는 여러 곳에서 똑같은 방식으로 계산되는 변수를 발견할 때마다 함수로 바꿀 수 있는지 살펴본다

## 내 생각

- 클래스 내부에서 변수를 사용할 때 내가 자주 사용하는 리팩토링 패턴 중 하나 이다.
- 만약 클래스 내부의 질의 함수로 만들지 않는다면, 어떻게 될까? 응집성이 유지 되지 않은 채, 떨렁 메소드 하나만 분리될 것이다. 이런 경우를 방지하기 위해서 즉, 응집성을 높이면서 코드의 가독성을 높이는 방식으로 활용한다

# 7.5 클래스 추출하기

## 중요 내용

- 메서드와 데이터가 너무 많은 클래스는 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.
- 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다.
- 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다

## 내 생각

- 클래스의 메서드가 많아지는 이유는 해당 클래스가 너무 많은 책임을 가지고 있기 때문 일 수 있다.
- 이 때는 적극적으로 클래스를 나누는 시도를 해야한다. 개인적으로 너무 잘게 나눠서 문제 되는 경우 보다 나누지 않아서 문제가 되는 경우를 훨씬 더 많이 보았다. 명확하게 책임이 2개 이상이라 판단되면 클래스 분리를 고민해보자.

# 7.6 클래스 인라인하기

## 중요 내용

- 두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인 한다.

## 내 생각

- 클래스 인라인은 나의 경우에 두 클래스 기능을 다르게 분배하고 싶을 때, 나눌 필요없이 합쳐도 되는 시기에 사용한다고한다. 나의 경우는 대개의 경우에 클래스를 일단은 크게 작성하고, 후에 분리하는 리팩토링을 자주 쓰다보니, 혹시 잘못 추출 했을 때, 되돌리는 용도를 제외하곤 해당 패턴은 많이 쓰는 것 같진않다.

# 7.7 위임 숨기기

## 중요 내용

- 서버 객체의 필드가 가리키는 객체의 메서드르르 호출하려면 클라이언트는 이 위임 객체를 알아야 한다. 위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야 한다. 이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.
- 위임 객체가 수정되더라도 서버 코드만 고치면 되며, 클라이언트는 아무런 영향을 받지 않는다.

## 내 생각

- 위임에 대해서는 실무에서 제대로 코드리뷰를 못하는 경우가 많다. 파이썬에서는 이 예제에서 보여주는 클라이언트 코드가 자주 나오는 편이다.
- 아마도 개발자들이 이런 위임의 필요성, 중요성을 잘 이해하고 있지 못하기 때문에, 내부 정보가 드러나지 않아야 하며, 그 작업을 위임해서 해줄 메서드에만 클라이언트가 의존하도록 하는 방법에 대해서 어떤 필요성을 느끼지 못하는게 아닐까 라는 생각이다. 나 또한 마찬가지이다.

# 7.8 중개자 제거하기

## 중요 내용

- 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버의 위임 메서드를 추가해야 하는데 ,이렇게 기능을 추가하다 보면 단순히 전달만 하는 위임 메서드들이 점점 성가셔진다
- 어느저도 까지 숨겨야 적절한지 판단하기란 쉽지 않지만, 우리에게는 다행히 위임 숨기기와 중개자 제거하기 리팩터링이 있으니 크게 문제는 되지는 않는다.

## 내 생각

- 어떤 값을 저장해야해서, django model instance의 save 메소드를 써야할 때, 이런 경우가 자주 발생하는 것 같다. 나의 경우는 대개의 경우에 save()메소드를 호출하는 책임을 모델 클래스 내부에서 구현이 되어야한다고 생각하는 편인데, 이 책에서 말한 경우처럼 단순히 전달만 하는 (?) 느낌의 위임 메서드들이 많아지게 되는 경우가 생긴다
- 그럼에도 불구하고 나는 확실하게 위임해야할 것은 위임하는게 좋다고 생각하는 편인다 책의 주석에 나오는 디미터의 원칙을 최대한 지키는 쪽으로 문제를 많이 생각해보곤 한다.

# 7.9 알고리즘 교체하기

## 중요 내용

- 나는 더 간명한 방법을 찾아내면 복잡한 기존 코드를 간명한 방식으로 고친다.
- 이 작업을 착수하려면 반드시 메서드를 가능한 한 잘게 나눴는지 확인해야 한다.

## 내 생각

- 나 같은 경우도 이 패턴을 자주 활용한다. 물론 시간 여유가 어느정도 있을 때, 코드를 좀 더 읽기 쉽게 하고 확장하기 쉬운 구조를 바꾸기 위해서 기존 코드를 더 가독성 좋은 형태로 변경하는 경우가 있다.
- 이 패턴을 적용하기 힘든 경우는 이 책의 1장에서 나온 것 처럼 하나의 함수안에 너무나도 많은 로직이 들어있을 때 이다. 이럴 때는 이 패턴을 적용하기 전에 기존 함수안에 구현된 내용들을 책임별로 잘 쪼개주는 작업이 선행 되어야만 한다고 생각한다. 그래야 더 리팩토링하기 쉬움..