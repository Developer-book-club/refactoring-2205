# CH 12. 상속 다루기

# 12.1 메서드 올리기

## 중요 문장

- 중복되었다는 것은 한쪽의 변경이 다른 쪽에는 반영되지 않을 수 있다는 위험을 항상 수반한다.
- 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기를 고려 해보자

## 내 생각

- 개인적으로 중복의 폐해는 본인이 당해보는게 가장 좋은 것 같다. 중복으로 인해서 고치기 힘들었던 적이 있다던지, 일불 못고친 부분이 있어서 장애를 경험했다던지.. 등등을 경험해보면 중복이 보이면 자연스레 고치게 될 수 있을 것 같다
- 최근에 나도 테스트 코드 내에서의 중복을 제대로 처리하지 않아서, 수정할 때 고생했던 적이 있다.
- IDE 가 매우 발전해서, 중복이 있더라도 수정하는데 크게 무리가 없긴 하다. 어찌보면.. 이런 IDE 의 발전이 중복을 완전히 없애는데 악영향을 끼치는 것은 아닌가? 라는 생각도 든다

# 12.2 필드 올리기

## 중요 문장

- 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.

## 내 생각

- 상속하고 있는 서브 클래스에 겹치는 필드가 있을 때, 부모 클래스로 필드를 옮기는 것인데, 굳이 패턴이라고 말하지 않아도 자연스레 리팩토링 하는 항목 중 하나 이다.

# 12.3 생성자 본문 올리기

## 중요 문장

- 생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
- 생성자를 팩터리 함수로 바꾸기를 고려해본다

## 내 생각

- 최근에 백엔드 단에서 service layer 관련 코드를 클래스 베이스로 작성하다보니, 이 생성자를 어떻게 다뤄야 하는지에 대한 고민이 많다 값 초기화 해주는 부분을 생성자로 다 몰아서 처리하는게 맞을지, 아니면 적절하게, public method 가 실행될 때, 인자로 값을 넘겨주면 될지.. 나 나름의 답은 왠만하면 생성자로 몰아주는 대신에, 생성자 내에서 내부 필드로 지정되어서 꼭 사용될 필요가 없다면 public method의 인자로 넘겨주는 것이다.

# 12.4 메서드 내리기

## 중요 문장

- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔하다

## 내 생각

- 공통으로 사용될 것으로 생각했었는데,  그렇지 않은 경우에 이 패턴을 사용해 볼 수 있을 것 같다. 추가적으로  책에서 자세히 나오지 않았지만, 이런 함수들이 많다면, 상속으로 처리하는게 맞는지? 에 대해서 고민 또한 필요할 것 같다

# 12.5 필드 내리기

## 중요 문장

- 서브 클래스 하나 에서만 사용하는 필드는 해당 서브 클래스로 옮긴다

## 내 생각

- 메서드 옮기는 것과 마찬가지로, 서브 클래스 모두에서 쓰지 않는다면 굳이 부모 클래스에 정의해두고 쓸 필요가 없다

# 12.6 타입 코드를 서브클래스로 바꾸기

## 중요 문장

- 타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
- 서브클래스는 두 가지 면에서 특히 매력적이다.
    - 첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.
    - 두 번째 매력은 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.

## 내 생각

- 이 리팩토링 기법은 개인적으로 base 클래스가 잘 잡혀있고, 각 타입을 명확하게 분류 할 수 있다면 복잡하게 if~else로 관리될 로직을 각 서브 클래스 별로 깔끔하게 유지할 수 있는 좋은 방법이라고 생각한다

# 12.7 서브클래스 제거하기

## 중요 문장

- 서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다.
- 하지만 소프트웨어 시스템이 설장함에 따라 서브 클래스로 만든 변종이 다른 모듈로 이동하건 ㅏ오나전히 사라지기도 하면서 가치가 바래기도 한다.

## 내 생각

- 굳이 필요 없이 남아있는 죽은 코드라면, 무엇이든 바로 삭제하도록 하자

# 12.8 슈퍼클래스 추출하기

## 중요 문장

- 상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦았다.
- 슈퍼클래스 추출하기의 대안으로는 클래스 추출하기가 있다. 어느 것을 선택하는냐는 중복 동작을 상속을 ㅗ해결하느냐 위임으로 해결하느냐에 달렸다

## 내 생각

- 어떤 클래스 들 끼리 공통으로 쓰고있는 요소를 발견했을 때, 그 공통 요소를 뽑아서 클래스를 새로 만들고 슈퍼클래스로 지정 하라는 내용이다.  일단은 슈퍼클래스를 만들어 보되, 굳이 슈퍼클래스로 만들 필요가 없다면 책에 나온 것처럼 합성을 고려해보는 것이 좋다. 내가 여기저기서 듣기론 상속을 잘 쓰는 경우보다 잘 못쓰는 경우가 많아서, 애초에 합성만 제공하는 언어도 있다고 들었다. 암튼 공통으로 뽑아서 슈퍼클래스를 만들는 스텝을 먼저 하되, 항상 상속으로 적합한지 고려가 필요하다

# 12.9 계층 합치기

## 중요 문장

- 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재할 이유가 사라지는 경우가 생기기도 한다 바로 그 둘을 하나로 합쳐야 할 시점이다

## 내 생각

- 이전에 보았던 리팩토링 패턴들과 같이 굳이 독립적으로 서브클래싱 될 필요가 없을 만큼 비슷하다면, 서브 클래싱 하는 것은 낭비이다. 이 때는 합쳐주도록 리팩토링 해주자

# 12.10 서브클래스를 위임으로 바꾸기

## 중요 문장

- 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의할 수 있다. 즉, 상속보다 결합도가 훨씬 약하다. 그래서 서브클래싱(상속) 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 한다.
- 상속 보다 컴포지션을 사용하라. 여기서 컴포지션은 사실상 위임과 같은 말이다. 많은 사람이 이 말을 상속은 위험하다고 받아들여서 상속을 사용하면 절대 안된다고 주장하기도 한다.
- 처음에는 상속으로 접근한 다음, 문제가 생기기 시작하면 위임으로 갈아탄다
- 디자인 패턴 책에 익숙한 사람이라면 이 리팩토링을 서브클래스를 상태 패턴이나 전략 패턴으로 대체 한다고 생각하면 도움이 될 것이다. 구조적으로 보면 이 두 패턴은 똑같이 호스트 위임 방식으로 계층 구조를 분리 해준다.

## 내 생각

- 상속과 관련해서 책에서는 상황에 따라서 상속과 위임을 적당히 써야함을 말한다. 이전까지 내가 들었던 혹은 봤던 책에서는 상속은 꼭 필요한 경우에만 사용하고, 대신 위임을 적극활용하라는 것과는 조금은 반대되는 내용이였다. 이유는 상속이 결합도를 높이기 때문이다
- OOP에 그렇게 까지 익숙하지 않다보니 이러한 주장에 대해서 아직까지 나 스스로 판단내려서 뭐가 맞다고 하기는 힘든 상태인데, 이를 계기로 상속과 합성 관련된 부분에 대한 학습과 경험이 필요하다고 느꼈다

# 12.11 슈퍼클래스를 위임으로 바꾸기

## 중요 문장

- 객체지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이다. 기존 클래스를 상속하여 입맛에 맞게 오버라이드하거나 새 기능을 추가하면된다. 하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 한다.
- 위임을 이용하면 기능 일부만 빌려올 뿐인, 서로 별개인 개념임이 명확해진다.
- 그래서 상속을 먼저 적용하고, 나중에 문제가 생기면 슈퍼클래스를 위임으로 바꾸라는 것이 나의 조언이다

## 내 생각

- 12.10에서 말했던 것과 이어지는 내용이다. 이전까지 상속에 대해서 주로 부정적인 뉘앙스의 글혹은 강의만 보았었는데, 이 책에서는 상속을 쓸 수 있을 때는 확실히 상속을 쓰는게 좋다고 말하는게 재미있는 포인트 인것 같다.
- 또한 책이 리팩토링 책이다 보니, 일단 상속으로 적용하고, 문제가 생겼을 때 합성으로 변경하라고 말하고 있는데, 언제든지 변경할 수 있다면, 충분히 활용해볼 수있는 방법이라고 생각한다