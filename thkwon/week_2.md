# CH1. 리팩터링: 첫 번째 예시

## 중요문장

1. 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
2. 모든 수정이 두 함수에 일관되게 반영 되도록 보장해야 한다 게다가 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정 과정에서 실수할 가능성도 커진다
3. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드 부터 마련해야한다
4. 자가진단 여부는 매우 중요하다. 그렇지 않으면 테스트 결과를 노트에 적어둔 값과 일일이 눈으로 비교해야 하는데, 속도가 상당히 떨어지게 된다
5. 한 가지를 수정할 때마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다
6. 이처럼 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다.
7. 하나의 리팩터링을 문제 없이 끝낼 때 마다 커밋한다
8. 함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다.
9. 함수의 반환 값에는 항상 result 라는 이름을 쓴다
10. 좋은 코드 라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 한다. 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말기 바란다.
11. 지역변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다.
12. 임시변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽니다. 따라서 다음으로 리팩터링은 이런 변수들을 제거하는 것이다.
13. 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다. 똑똑한 컴파일러들은 최신 캐싱 기법등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문이다.
14. 리팩토링으로 이한 성능문제에 대한 내 조언은 특별한 경우가 아니라면, 일단 무시하라는 것이다
15. 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬어진다
16. 좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가 다
17. 나는 취향을 넘어선 관점이 분명 존재하며, 코드를 수정하기 쉬운 정도야말로 좋은 코드를 가늠하는 확실한 방법이라고 믿는다 코드는 명확해야 한다
18. 리팩토링을 효과적으로 하는 핵심은 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.

## 내 생각

1. 1 → 어떤 기능을 추가 해야하는데, 구조가 너무 복잡하면, 기능을 추가하기 쉬운형태로 리팩토링 하는게 어찌보면 당연하게 생각될 수 있다 그러나 돌이켜서 생각해보면, 구조가 복잡했을 때, 리팩토링을 하려던 시도 보다는 복잡한 구조 자체에 어떻게든 끼워넣으려고 했던 적이 훨씬 많았단 것 같다. 이 책을 통해서 배우는 리팩토링 기법을 통해서 앞으로는 코드 구조를 확장하기 쉽고, 만들어 둔 후, 추가 작업하는 것을 적극적으로 실천할 수 있도록 하면 좋을 것 같다.
2. 2 → 만약에 중복을 처리하지 않고, 양쪽 코드를 유지한채로 둔다면, 반드시 모든 수정에 대해서 일관되게 반영되도록 보장해야한다. 그렇지 않을 때, 동작이 달라질 것이기 때문에 당연히 기대 한대로 동작하지 않을 것이다. 또한 이런 중복 코드가 셀 수 없이 많다면? 실수할 가능성도 더 높아질 것이기 때문에 중복은 가장 큰 코드 스멜로 반드시 처리해야만 한다
3. 3 → 간혹 리팩토링 작업을 할 때, 테스트 코드 없이 작업하면서, 이전 기능에 대한 regression이 지켜지지 않는 경우가 있다 리팩토링을 하는 목적이 regression을 지키면서, 코드 구조를 변경하는 것인데, regression을 지키지도 못하면서 코드 구조를 변경하는 것은 리팩토링한 것으로 볼 수 없을 것 같다 리팩토링 작업을 할 때는 Regression은 항상 유지되어야 하고, 이를 위해서 테스트는 필수이다.
4. 4 → 테스트 자동화에 대한 이야기 이다. 테스트가 1~2개일 때는 수동으로 확인하는데 전혀 문제가 없지만, 1000개, 2000개 라면? 절대로 수동체크하는게 자동체크하는 것보다 빠를 수가 없다
5. 5 → 리팩토링 작업을 대규모로 하다보면 자연스럽게 알게될 이야기 이다. 변경 폭을 좁히면 좁힐 수록 수월하게 리팩토링 작업이 가능하며, 넓힐 수록 더욱 힘들게 된다.
6. 7 → 개인적으로 언제 커밋을 할 것인가에 대해서 고민했던 적이 있었다 red → green → refactor 사이클에서 green이 된 시점과 refactor 시점 모두 커밋을 한적이 있었는데, 불필요하게 커밋이 늘어난다는 느낌이 많이 들었다 현재는 refactor 이후에 커밋을 하는데 꼭 필요한 커밋을 한다는 측면에서 좀 더 좋다는 생각이다
7. 8 → 어찌 보면 이것은 당연한 일이다. 꼭 추출한 이후에 코드를 명확히 어떻게 할지 검토하는게 아닌, 리팩토링 하는 혹은 코드리뷰, 내가 코드 작성하는 전반에 걸쳐서 변경하기 쉽고 읽기 좋은 코드를 작성하기 위해서 노력해야만한다.
8. 9 → 이 내용은 개인적으로는 한번 적용해보고 싶긴한데, 너무 제너럴한 변수명이 아닌가? 라는 생각이 든다 실제로 한번 해봐야 어떤 장점/단점이 있을지 알 수 있을 것 같다.
9. 12 → 임시변수를 개인적으론 가독성 증진을 위해서 사용하는 편인데, 이번을 계기로 어떻게 리팩토링하는게 좋을지 배워보면 좋을 것 갖ㅌ다.
10. 13, 14 → 성능과 관련해서 사람마다 생각이 다를 순 있지만, 나의 경우도 리팩토링 하는 단계에서는 일단 성능은 고려하지 않고 진행해야한다고 생각한다 리팩토링하는 단계에는 온전히 코드를 수정하기 쉽고, 읽기 쉽게 수정하면서 테스트를 통과하는 것에만 집중해야한다. 그러나 그렇다고 성능을 아예무시할 순 없다 성능은 리팩토링 이후에 따로 반드시 챙겨야할 사항이다 다만 리팩토링 시기에는 덜 집중하는 것이 맞는 것 같다.
11. 16, 17 → 이번 리팩토링 책을 읽으면서, 개인적으로 나는 어떻게 코드를 작성해야하는가에 대한 생각이 구체화 되었다 그전에는 단순하게 읽기 쉽게 작성하는 것을 최고의 가치로 여겼는데, 여기에 더하여서 수정하기 쉽게 의 가치에 대해 알게되면서, 내가 코드를 작성할 때 반드시 고려해야할 것으로 생각해야겠다는 생각이 들었다
12. 18 → 리팩토링이라는 단어를 통해서 작가가 하고 싶은 말은 작은 단계단계를 거치면서, 조금씩 코드 구조를 개선하여서 결론적으로 더 수정하기 쉽고 읽기 쉬운 코드, 코드 구조를 되도록 하자 인 것 같다는 느낌이 들었다