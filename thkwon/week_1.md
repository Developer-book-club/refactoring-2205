# Ch02. 리팩토링 원칙

# 2.1 리팩터링 정의

## 키워드

- 리팩터링

## 중요 문장

- 리팩터링
    - 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내느 일이다.
- 누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링 한 것이 아니다
- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다

## 내 생각

- 리팩터링의 본질은 코드를 더 읽기 쉽게 하여서, 이해하고 수정하기 쉽게 만드는 것 이라는 것을 확실하게 알 수 있었다
- 예전에 생각해보면, 뭔가 코드의 심미적인 것에 꽂혀서 리팩토링을 수행한적이 많았는데, 그 보다 내 의도를 더 잘 드러내 줄 수 있는 읽기 좋은 코드를 목표로 해야함을 알 수 있었다

# 2.2 두 개의 모자

## 키워드

- 기능추가 vs 리팩터링

## 중요 문장

- 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

## 내 생각

- 기능을 추가할 때는 기능추가에만 집중, 리팩터링 할 때는 리팩터링에만 집중하는게 좋다는 얘기이다. 이것은 TDD를 직접 해보면서 두개를 섞어서 할 시에 불편함을 확실히 느낄 수 있다

# 2.3 리팩터링 하는 이유

## 키워드

- 설계 개선
- 이해
- 버그
- 프로그래밍 속도

## 중요 문장

- 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.
- 내 의도를 더 명확하게 전달하도록 개선할 수 있다.
- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.
- 리팩터링하면 코드 개발 속도를 높일 수 있다.

## 내 생각

- 문장 중에서 요즘 가장 많이 느끼는 것은 `내 의도를 더 명확하게 전달하도록 개선할 수 있다` 이다. 코드를 더 읽기 좋게 리팩토링 하는 이유는 내가 쓴 코드의 내 의도를 다른 사람에게 명확하게 더 잘 드러내기 위함이라고 생각한다
- 이러한 전제 속에서 버그를 쉽게 발경할 수 있고, 개발속도와 디버깅 속도도 빨라질 수 있는 것으로 본다

# 2.4 언제 리팩터링해야 할까?

## 키워드

- 3의 법칙

## 중요 문장

- 스트라이크 세 번이면 리팩터링 하라
- 준비를 위한 리팩터링
    - 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
- 이해를 위한 리팩터링
    - 나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
- 쓰레기 줍기 리팩터링
    - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
- 계획된 리팩터링과 수시로 하는 리팩터링
    - 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.
- 보기 싫은 코드를 발견하면 리팩터링 하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다
- 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 떄마다 해야한다
- 오래 걸리는 리팩터링
    - 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는편이 효과적이다
- 코드 리뷰에 리팩터링 활용하기
    - 코드리뷰의 결과를 더 구체적으로 도출하는데에도 도움된다
- 리팩토링 하지 말아야 할 때,
    - 나는 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다.
    - 내부 동작을 이해해야할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
    - 리팩토링하는 것보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링 하지 않는다.

## 내 생각

- 이 파트에서 리팩토링을 언제해야할지에 대해서 경우 별로 자세히 정리해줘서 회사에서 일할 때 충분히 활용할 수 있겠다는 생각이 들었다
- 리팩토링 하지 말아야 할 때에서, 내부 동작을 이해해야할 시점에 리팩터링해야 효과를 제대로 볼 수 있다는 말이 크게 공감 되었다 내용이 완벽히 이해되지 않은 상태에서 섣부른 리팩토링은 다른 사람이 내 의도를 제대로 이해하지 못할 가능성 이 높을 수 있기 떄문이다.

# 2.5 리팩터링 시 고려할 문제

## 키워드

- 경제적인 효과
- CI
- 테스팅
- CD
- 레거시
- 

## 중요 문장

- 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것
- 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편이다.
- 리팩터링을 더 자주 하도록 노력해야 한다.
- 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다.
- 리팩토링은 개발기간을 단축하고자 하는 것이다.

## 내 생각

- 나 같은 경우에 리팩토링을 특정 작업으로 쪼개서 진행하고 있지 않다.
- TDD를 하게 되면 자연스럽게 리팩토링을 하게 된다 나는 TDD 싸이클을 돌면서 리팩토링하는 것을 선호한다

# 2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)

## 키워드

- 유연성
- YAGNI
- 진화형 아키텍쳐

## 중요 문장

- 리팩터링이 아키텍쳐에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.

# 2.7 리팩터링과 소프트웨어 개발 프로세스

## 키워드

- TDD
- 자가 테스트 코드
- 지속적 통합

# 2.8 리팩터링과 성능

## 키워드

- 성능 튜닝
- 성능

## 중요 문장

- 직관적인 설계 vs 성능은 중요한 주제다.
- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만, 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
- 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.
- 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다. → 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.
- 리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

## 내 생각

- 개인적인 의견이지만, 성능은 프로그래밍에서 분명히 신경써야할 요소가 맞지만, 지나치게 따지게 되면 오히려 독이 될 수 있다고 생각한다. 성능과 가독성은 어느정도의 trade off가 있다고 생각한다 어느 하나를 신경쓰면 어느하나가 소홀해질 수밖에 없다고 생각한다
- 그렇기 때문에 개인적으로는 가독성을 신경쓰되, 반드시 성능이 필요한 곳은 성능에 집중해서 개발하는 방법을 더 선호한다
- 또한 위 책에서 말한 결국에는 리팩토링을 함으로써, 코드를 튜닝하기 쉬워지기 때문에 더 빠른 소프트웨어를 얻게 된다 라는 말에도 적극 동의한다




# Ch03. 코드에서 나는 악취

# 3.1 기이한 이름

## 키워드

- 이름

## 중요 내용

- 코드는 단순하고 명료하게 작성해야한다.
- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경써서 이름을 지어야 한다
- 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 내 생각

- 작가가 이것을 1번으로 둔 이유가 있을 것이라고 생각한다 당연하게도 매우 중요하기 때문일 것 이다
- 개인적으로도 이름을 잘지어야된다는 것에 매우 동의하고, 의도를 표현하는데 다른 모든 요소중 가장 영향력이 크다고 생각한다

# 3.2 중복 코드

## 키워드

- 중복

## 중요 내용

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

## 내 생각

- 중복은 매우 대표적인 스멜 중 하나이다. 같은 코드가 여러군데 흩어져있을 때, 수정이 필요하면? 모든 곳을 다 수정해야한다 근데 만약 몇군데를 빼먹고 안고치면, 그런 경우에 대개 버그가 많이 발생하게 된다 이런 경우를 막기위해서라도 중복은 최대한 없애는게 좋다라는 의견에 동의한다

# 3.3 긴 함수

## 키워드

- 짧은 함수

## 중요내용

- 우리의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
- 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다.
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
- 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다
- 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다

## 내 생각

- 예전에는 긴함수에 대해서 별 다른 생각이 없었다.
- 그러다보니, 내가 작성한 함수 중에 매우 긴 함수들이 많았던 것으로 기억한다.
- 내가 구현할 비즈니스 로직을 서비스 layer를 두고 클래스 기준으로 책임을 분리하여 구현하면서, 위 냄새의 나쁜점과 고쳤을 때 뭐가 좋아졌는지 확실히 알 수 있었다

# 3.4 긴 매개변수 목록

## 키워드

- 매개변수

## 중요내용

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.

## 내 생각

- 매개변수는 당연하게도 많으면 많을 수록 보기 힘들어진다. 적당한 수가 좋다고 생각한다 그 적당한 수는 각각 코드의 문맥에 따라 다를 것이고, 작성자가 적절히 판단해야만 한다.

# 3.5 전역 데이터

## 키워드

- 전역 데이터

## 중요내용

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제다.

## 내 생각

- 가변적인 전역데이터 라면 큰 문제가 될 수 있다
- 그러나, 개인적으로 가변적이지 않은 데이터라면, 무조건 전역 데이터가 좋지 않다고 말하긴 어려울 것 같다 → 필요할 때는 적절히 써야한다는 것이다.

# 3.6 가변 데이터

## 키워드

- 가변 데이터

## 중요내용

- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다. 특히 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.

## 내 생각

- 가변 데이터의 경우는 변수 라이프 사이클의 스코프를 최대한 짧게 하는게 좋다고 생각한다 특히 변수하나의 라이브 사이클이 클 때, 위처럼 예상치 못한 버그가 발생하게 된다.

# 3.7 뒤엉킨 변경

## 키워드

- SRP

## 중요내용

- 뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

## 내 생각

- 애매하게 이름이 지어진 메소드에 대해서는 이 냄새라고 판단하고, 책임을 적절히 나눠서 함수 혹은 클래스로 추출할 수 있을 것 같다

# 3.8 산탄총 수술

## 키워드

- 산탄총 수술

## 중요내용

- 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다.
- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 때 풍긴다

## 내 생각

- 내가 이해하고 있는 산탄총 수술은 어떤 한 부분을 고쳤을 때, 연쇄적으로 여기저기서 문제가 발생하는 것이다.
- 이를 막기위해서는 중복 없이 각 책임별로 함수, 클래스가 잘 나눠져서 문제가 여기저기 퍼져나가는 것을 격리할 수 있어야 한다

# 3.9 기능 편애

## 키워드

- 책임

## 중요내용

- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.
- 함께 변경할 대상을 한데 모으는 것이다.

## 내 생각

- 이 냄새 역시 클래스를 책임별로 제대로 나누지 않았을 때, 뜬금 없는 코드들이 클래스의 속성이나 메소드로 추가되는 것을 말한다
- 개인적으로 파이썬에서는 staticmethod가 사용되는 경우에 이를 staticmethod로 그냥 두어야할지, 다른 클래스혹은 함수 책임으로 돌려야할지 판단이 필요하다

# 3.10 데이터 뭉치

## 키워드

- high cohesion, loose coupling

## 중요내용

- 간단한 레코드 구조가 아닌 클래스로 만들기를 권했음을 눈치챘는가? 클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생기기 때문이다. 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

# 3.11 기본형 집착

## 중요내용

- 이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현 하기엔 아쉬움이 많다

# 3.12 반복되는 switch 문

## 키워드

- 

## 중요내용

- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.
- 이럴 때, 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.

## 내 생각

- 책에서 예시를 적용해주지 않아서 정확한 맥락을 알 수 없지만, 중복으로 쓰이는 switch문에 대한 경계인 것같다.
- 개인적으로는 if, switch 문이 필요할 때는 사용이 필요하다고 생각하고, 모든 것을 다형성으로 문제를 해결하려는 것은 오버엔지니어링 일 수 있다고 생각한다
- 그렇기 때문에 상황과 해당 코드의 문맥에 따라서, 적절하게 선택해서 적용해야 한다

# 3.13 반복문

## 키워드

- 반복문

## 중요내용

- 반복문을 파이프라인으로 바꾸기 를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

## 내 생각

- 파이썬의 경우엔, list comprehension 같은 기능들로 반복문을 제어할 수 있다

# 3.14 성의없는 요소

## 키워드

- useless

## 중요내용

- 우리는 코드의 구조를 잡을 때, 프로그램 요소를 이용하는 걸 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다.
- 그렇지만 그 구조가 필요 없을 때도 있다. .. 중략 .. 사정이 어떠하든 이런 프로그램 요소는 고이 보내드리는게 좋다.

## 내 생각

- 실제로 안쓰이는 코드는 남겨두지 말고 무조건 지워라! 라고 말하고 있다
- 개인적으로도 쓰이지 않는 코드 때문에 헷갈렸던 적이 많다 안쓰는 코드는 바로바로 지우자

# 3.15 추측성 일반화

## 키워드

- 추측

## 중요내용

- 이 냄새는 나중에 필요할 거야 라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다 그 결과는 물론 이해하거나 관리하기 어려워진 코드다.

## 내 생각

- 위의 성의 없는 요소와도 어느정도 비슷한 내용이라고 생각한다 미래는 예측할 수 없기 때문에 어떤 고객의 요구사항변동이 있을지 알 수 없다 그렇기 때문에 섣부르게 추측하여 일반화 한다면, 머지 않아 그 일반화한 것을 전부 고쳐야할지 모르기 때문에, 추측보다는 당장 필요한 구현에만 집중하는 것이 좋다고 생각한다

# 3.16 임시 필드

## 키워드

- 임시 값

## 중요내용

- 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다. 그래서 사용자는 쓰이지 않느 것 처럼 보이는 필드가 존재하는 이유를 파악하느라 머리를 싸매게 된다.

## 내 생각

- 여기서 말하는 임시 값이 예제가 없어서 정확한 맥락은 이해할 수 없었지만 대략적으로는, 위의 냄새들과 같이 헷갈림을 일으킬 수 있는 요소들은 굳이 코드에 남겨두지 말라는 의도로 인지하였다

# 3.17 메시지 체인

## 키워드

- 메세지 체인

## 중요내용

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른객체를 요청하는 식으로 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다

## 내 생각

- 아직까지는 객체에 객체에 객체로 이어지는 코드를 작성해본적이 없어서 잘 와닿지 않았다 이후에 예제코드를 통해서 확인이 필요할 것 같다

# 3.18 중개자

## 키워드

- 위임

## 중요내용

- 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가? 이럴 때는 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.

## 내 생각

- 이 냄새의 경우에도 지나치게 위임을 할 때의 문제점을 말하고 있다 마찬가지로 문제상황에 대한 구체적인 예제가 있었다면 좋았을 것 같다
- 함수 인라인 리팩토링 기법등으로 해결해볼 수 있을 것 같다

# 3.19 내부자 거래

## 중요내용

- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며, 그래서 모듈 사이의 데이터 거래가 많으면 결합도가 높아진다고 투덜 댄다.

# 3.20 거대한 클래스

## 키워드

- 거대한 클래스

## 중요내용

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복코드가 생기기 쉽다.
- 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복코드와 혼동을 일으킬 여지가 크다.
- 클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지 단서를 얻을 수도 있다.

## 내 생각

- 클래스도 그렇고 함수도 그렇고, 작게 유지하려는 노력이 필요하다.
- 대개의 경우에 한 클래스에서 모든 것을 다하려는 욕심 때문에 클래스가 거대해지는 경우가 많다
- 개인적으로는 책임에 대한 설계를 미리 정의한 이후에 클래스를 책임에 맞게 만드는편이다 물론 구현중에 추가로 책임을 더 나눠야한다면, 어딘가에 적당히 붙여서 하는 것보다 책임을 적극적으로 나누는 방향으로 코드를 작성한다

# 3.21 서로 다른 인터페이스의 대안 클래스

## 중요내용

- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단 고체하려면 인터페이스가 같아야 한다.

# 3.22 데이터 클래스

## 중요내용

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다 그저 데이터 저장용도로만 쓰이다 보니 다른 클래스가 너무 깊이 까지 함부로 다룰 떄가 많다.
- 이런 클래스에 public 필드가 있다면 누가 보기 전에 얼른 레코드 캡슐화하기 로 숨기자, 변경하면 안되는 필드는 세터 제거하기로 접근을 원천봉쇄 한다.

# 3.23 상속 포기

## 키워드

- 상속

## 중요내용

- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
- 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는 것은 상당히 무례한 태도이다.
- 이럴 때는 서브클래스를 위임으로 바꾸기 나 슈퍼클래스를 위임으로 바꾸기를 활용해서 아예 상속 메커니즘에서 벗어나 보자.

## 내 생각

- 언어 마다 상속에 대해서 위 문제가 있을 때 처리하는 방식이 다를 수 있을 것 같다. 이후 책 내용을 보면서, 이 부분의 해결책에 대해서는 개인적으로 정리해서 활용해봄직 하다고 느꼈다

# 3.24 주석

## 키워드

- 주석

## 중요내용

- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
- 주석이 많으면 이 장에서 소개한 온갖 악취를 풍기는 코드가 나오기 쉽다. 실제로 악취가 너무 심해서 리팩터링으로 냄새를 걷어내고 봤더니, 상당량의 주석이 군더더기 였던 적이 많았다
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다

## 내 생각

- 개인적으로 주석을 적절하게 사용한다면 코드 읽는데 도움을 많이 준다고 생각한다
- 그러나 그렇다고 해서 무조건적으로 주석이 남용되면 오히려 코드 읽는데 방해가 되기 때문에, 코드 작성하는 사람은 이 밸런스를 잘 맞춰야 할 것이고, 주석이 많아지는 경우에 항상 주석 내용은 추출할 수 없을지 고민이 필요하다




# Ch04. 테스트 구축하기

# 4.1 자가 테스트 코드의 가치

## 중요내용

- 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자
- 테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.
- 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하기 어렵다
- 구현보다 인터페이스에 집중하게 된다는 장점도 있다.
- 리팩토링에는 테스트가 필요하다. 그러니 리팩터링하고 싶다면 테스트를 반드시 작성해야 한다

## 내 생각

- 위 중요 내용에 나온 모든 문장에 동의한다 특히 마지막에 리팩토링하고 싶다면 테스트를 반드시 작성해야한다 라는 문장에 극 공감한다.
- 가끔씩 리팩토링을 하는데 ,테스트가 없이 진행하거나, 구현코드를 변경하면서, 테스트도 변경하고 이를 리팩토링하는 경우도 보았다
- 내 경우는 명확하게 테스트가 마련되어있는 상태에서 구현코드의 구조를 고치는 것을 리팩토링으로 봐야한다고 생각한다

# 4.3 첫 번째 테스트

## 중요내용

- 실패해야 할 상황에서는 반드시 실패하게 만들자
- 자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.

## 내 생각

- 위의 자주 테스트하라는 짧은 피드백 주기와도 일치하고, TDD의 컨셉과도 일치한다
- 개인적으로 같이 일하는 개발자들에게 TDD를 적극 권한다 짧은 피드백 주기로 얻을 수 있는 장점이 많기 때문이다.
- 꼭 TDD가 아니더라도 일을 할 때, 같이 일하는 사람 간의 피드백 주기가 짧은쪽, 긴쪽의 경우 모두를 생각해보면 짧은 쪽이 압도적으로 실수도 적고 일하기 좋은 것을 느낄 수 있을 것 이다.

# 4.4 테스트 추가하기

## 중요내용

- 실패한 테스트가 하나라도 있으면 리팩터링하면 안된다 라는 의미로 흔히들 빨간 막대 일 때는 리팩터링하지 말라 라고 말한다

## 내 생각

- TDD 싸이클을 돌다보면, 리팩토링을 하는 케이스는 빨간불 이후에 파란풀이 들어올 때이다. TDD에 익숙하다면 위 문장에 대해서도 이해가 어렵진 않을 것이다

# 4.5 픽스처 수정하기

## 키워드

## 중요내용

- 테스트는 위험요인을 중심으로 작성해야 한다. 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를찾는 데 있다. 따라서, 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요가 업사.
- 테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽기 때문에 아주 중요한 포인트다.
- 잘못될까봐 가장 걱정되는 영역을 집중적으로 테스트하는데, 이렇게 해서 테스트에 쏟는 노력의 효과를 극대화하는 것이다.
- 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.
- 가장 선호하는 방식은 매번 새로운 픽스처를 만드는 것이다.
- 일반적으로 it 구문 하나당 검증도 하나씩만 하는게 좋다.

## 내 생각

- 개인적으로, 커버리지 측정을 하진 않지만 어느정도 커버리지가 높은게 좋다라고 생각한다
- 이 책에서 테스트는 위험요인을 중심으로 작성해야 한다라고 나와있는 부분은 인상 깊었다 물론 그전에도 위험요인 중심으로 작성했지만, 위험 요인보다는 모든 코드의 커버리지에 좀 더 초점을 맞추어왔기 때문이다.

# 4.6 경계 조건 검사하기

## 중요내용

- 범위를 벗어나는 경계 지점에서 문제가 생기면 어떤 일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.
- 경계를 확인하는 테스트를 작성해보면 프로그램에서 이런 특이 상황을 어떻게 처리하는게 좋을지 생각해볼 수 있다
- 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트 하자.
- 어차피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면, 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.
- 테스트를 너무 많이 작성하다 보면 오히려 의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다. 따라서 위험한 부분에 집중하는 게 좋다.

## 내 생각

- 위험한 부분에 집중하다보면, 자연스레 경계조건을 검사하게 된다 대개의 위험이 경계조건 내에서 발생하기 때문이다.
- 개인적으로, TDD 진행할 때, 해피패스, 언해피패스, 경계조건등을 미리 정의를 하고 단계별로 개발을 진행하고 있다.

# 4.7 끝나지 않은 여정

## 키워드

## 중요내용

- 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다.
- 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위테스트부터 작성하자
- 테스트 스위트가 충분한지를 평가하는 기준은 주관적이다

## 내 생각

- `버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위테스트부터 작성하자` 이 말이 포인트 이다. 버그를 확실하게 테스트를 통해 검증하면서 고칠 수 있는 방안이기 때문에 혹시 주변에 모르는 사람이 있다면 적극적으로 알려줄 필요가 있다고 생각한다