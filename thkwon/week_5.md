# CH 08. 기능 이동

# 8.1 함수 옮기기

## 요약

- 이 파트에서는 모듈성을 높이기 위해서, 각 책임에 따라서 좀 더 적절한 방향으로 함수를 옮기는게 필요하다는 주장을 하고 있다
- 앞에서 부터 계속 반복되고 있지만, 함수 혹은 클래스의 책임을 적절히 나누고 그 책임에 맞게 배치해야함을 계속 적으로 말하고 있다.

## 중요 문장

- 모듈성을 높이려면 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야한다.
- 보통은 이해도가 높아질수록 쇼포트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 왼다.
- 함수를 옮길질 말지를 정하기란 쉽지 않다. 그럴 땐 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보면 도움이 된다.

## 내 생각

- 책에서 말한 모듈성을 높이기 위한 방법은 흔히 말하는 `Low coupling, High cohesion` 문장으로 설명할 수 있을 것 같다. 결합은 최대한 줄이고, 응집은 높임으로 써, 책에서 말하는 모듈성을 제대로 이룰 수 있다고 생각한다.
- 이런 모듈화는 너무나도 당연한 얘기지만, 도메인에 대한 지식, 해당 언어나 프레임워크에 대한 지식이 갖춰질 수록 더 잘할 수 있다고 생각한다. 그렇기 때문에 언어나 프레임워크에 대한 이해는 기본이고, 특히 도메인에 대해서 확실히 이해하고 있어야 한다고 생각한다. 도메인에 대한 이해가 있어야만 설계가 수월하게 가능하기 때문이다.

# 8.2 필드 옮기기

## 요약

- 적절하지 않은 데이터 구조를 사용 했을 때, 코드가 복잡해질 수 있음을 경고한다 이때 제때 고치지 않으면 꺠진 유리창 이론에 의해서 프로젝트 전체 코드들이 잘못된 데이터구조에 종속되서 개발되는 경우가 생길 수 있기 때문에 잘못되었다고 판단되었을 때, 바로바로 고쳐줄 수 있어야 한다
- 바로 고칠 수 있기 위해서는 스스로 설계를 잘 할 수 있어야 하고, 설계를 하기위해선 도메인을 잘 알아야한다 계속 반복되는 내용이지만, 설계를 잘하기 위해서 도메인에 대한 이해는 정말로 필수이고, 도메인을 잘 파악하기 위해서 노력할 필요가 있다고 생각한다

## 중요 문장

- 프로그램의 진짜 힘은 데이터 구조에서 나온다. 주어진 문제에 적합한 데이터 구조를 활용하면 동작코드는 자연스럽게 단순하고 직관적으로 짜여진다.
- 가장 적합한 데이터 구조를 알아내고자 프로젝트초기에 분석을 해본 결과, 경험과 도메인 주도 설계 같은 기술이 내 능력을 개선해줌을 알아냈다.
- 현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야한다. 고치지 않고 데이터 구조에 남겨진 흠들은 우리 머릿속을 혼란스럽게 하고 훗날 작성하게 될 코드를 더욱 복잡하게 만든다

## 내 생각

- 나 또한 설계 할 때, 데이터 구조를 잘 잡는 것이 매우 중요하다고 생각한다 특히나 클래스와 메소드 설계 시에, 도메인에 따라서 어떻게 적절하게 설계하느냐에 따라서 구현의 복잡도가 결정이 되는 것 같다.
- 이러한 이유로 책에서도 언급된 DDD 같은 것을 공부해보면서 어떻게 하면 설계를 잘할 수 있을지에 대해서 고민해보고 있는 중이다
- 꺠진 유리창 이론은 코드에도 적용이된다고 생각한다 책에 나온 것처럼 잘못 설정된 데이터 구조를 고치지 않은채 그냥 두면은, 이후에 코드를 읽는 사람도, 코드를 추가하는 사람도 그래도 되겠거니 자연스레 나쁜 패턴을 머릿속에 인지하게 된다. 이런 것을 막기 위해서라도 반드시 좋지 않은 구조라 판단될 때마다 리팩토링이 필요하다

# 8.3 문장을 함수로 옮기기

## 요약

- 특정 함수 코드의 앞뒤에 중복코드가 반복될 때, 피호출 함수 내부로 합치는 내용을 말한다.

## 중요 문장

- 무언가 수정할 일이 생겼을 때 단 한곳만 수정하면 된다.
- 문장들을 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다.

## 내 생각

- 중복을 없앤다는 관점에서는 자주 쓸만한 리팩토링 기법이라고 생각한다
- 그 외 그리 특별한 것은 없는 것 같고, 이전부터 나온 중복을 없앤다는 것과 일맥상통한 것으로 보인다

# 8.4 문장을 호출한 곳으로 옮기기

## 요약

- 8.3에서 호출하는 쪽에서 모두 같은 동작을 한다는 가정하에 문장을 함수로 옮겼는데, 일부 호출자에게 다르게 동작하도록 바뀌어야 하는 상황에서, 해야하는 리팩토링 기법이다.

## 중요 문장

- 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다.
- 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 한다면, 이런 일이 벌어진다.
- 개발자는 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다.

## 내 생각

- 8.3, 4 모두 어떤 특별한 리팩토링 패턴이라기 보다는, 흔히 개발하면서 중복처리를 할 때, 의식하지 못한채 사용하는 리팩토링 패턴이라고 볼 수 있을 것 같다.

# 8.5 인라인 코드를 함수 호출로 바꾸기

## 요약

- 기존에 존재하는 함수와 같은 동작을 하는 인라인 코드가 존재한다면, 기존에 존재하는 함수로 변경하는게 좋다

## 중요 문장

- 함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때무에 함수를 활용하면 코드를 이해하기가 쉬워진다
- 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드를 발견하면 보통은 해당 코드를 함수 호출로 대체하길 원할 것이다.
- 특히 라이브러리가 제공하는 함수로 대체할 수 있다면 훨씬 좋다.

## 내 생각

- 바퀴를 다시 개발하지 말라는 관점에서, 적절한 리팩토링 기법이라고 생각한다.
- 책에서 말한대로, 인라인 코드를 대체할 수 있는 built-in 함수나, 기존에 존재하는 함수가 있다면 어찌 보면 중복으로 볼 수도 있기 때문에 반드시 변경 해주는게 좋을 것 같다

# 8.6 문장 슬라이드하기

## 요약

- 관련된 코드끼리는 최대한 모으고 추출할만하면, 메소드 혹은 클래스로 추출하자

## 중요 문장

- 관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다
- 관련 있는 코드들을 명확히 구분되는 함수로 추출하는게 그저 문장들을 한데로 모으는 것보다 나은 분리법이다

## 내 생각

- 내가 자주 사용하는 리팩토링 패턴 중  하나이다 나도 저자처럼 변수를 처음 사용할 때 선언하는 스타일을 선호한다. 도메인 혹은 의미적으로 관련된 코드들 끼리 묶어서 코드 읽는 것이 가독성에 더 좋다고 생각하기 때문이다.
- 더불어서, 이 리팩토링을 진행 한후에 적절하게 함수나 클래스 등으로 추출할 수 있는지도 고려하는게 좋고 적극적으로 추출하는게 좋다고 생각한다

# 8.7 반복문 쪼개기

## 요약

- 성능을 고려하는 것보다 우선하여서, for loop 또한 가독성을 기준으로 나누어 보자, 성능은 그 이후에 생각하자

## 중요 문장

- 각각의 반복문을 분리해두면 수정할 동작 하나만 이해하면 된다.
- 다시 한번 이야기하지만, 리팩터링과 최적화를 구분하자
- 오히려 반복문 쪼개기가 다른 더 강력한 최적화를 적용할 수 있는 길을 열어주기도 한다.

## 내 생각

- 이 파트에서 주장하는 내용은 꽤나 신박하다 내 경우도, for loop 1개로 처리될 수 있다고 판단되면 1개로 해결하려고 하지 굳이 2개로 쪼개려는 시도를 하지 않기 때문이다
- 그러나 for loop 내부에서 동작하는 코드들이 간단하지 않고 복잡하게 엮여 있다면 , for loop를 쪼개는게 오히려 가독성의 관점에서는 나을 수 있다는 것이다 물론 루프를 분리 하면서, 불필요하게 루프가 돌게 된다는 문제점이 분명히 있긴 하다 그럼에도 불구하고, 루프를 도는 N 값이 크지 않다면, 성능적으로도 크게 문제가 없을 것 이라는 생각이 든다

# 8.8 반복문을 파이프라인으로 바꾸기

## 요약

- 반복문을 파이프라인으로 변경해보자

## 중요 문장

- 컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다.
- 논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다

## 내 생각

- 함수형 프로그래밍 패러다임의 의견이 많이 들어가 있는 것으로 보인다 아직까지 함수형 패러다임에 대해서 잘 이해하고 있진 못하나, 순서대로 연산을 한다는 측면에서 좀 더 가독성을 높일 수 있다? 정도로 이해를 하였다

# 8.9 죽은 코드 제거하기

## 요약

- 안쓰는 코드는 내버려두지 말고 그때그때 바로 지우자

## 중요 문장

- 사용되지 않는 코드가 있다면 그 소프트웨어의 동작을 이해하는 데는 커다란 걸림돌이 될 수 있다.
- 코드가 더 이상 사용되지 않게 됐다면 지워야 한다.
- 지금은 코드가 몇줄 안되는 초기 단계부터 버전 관리 시스템을 사용하므로 더 이상은 필요치 않다

## 내 생각

- 필요없는 코드는 부채로 남겨두지 말고 그때그때 바로 지워야 한다
- 책에서 말한 것처럼 히스토리에 대해서 잘 모르는 사람이 괜히 코드를 봤다가 헛고생을 할 가능성도 있고, 사용되지 않는 코드를 괜히 import 해서 사용하는 경우도 발생할 수 있기 때문이다.
- 그러나 많은 경우에 이런 코드들을 그냥 두는 경우도 많다 바쁘다는 이유로.. 삭제에 대한 사이드 이펙트를 예상 할 수 없어서? 등등..
- 특히 삭제시에 사이드 이펙트가 걱정 된다면, 코드자체가 격리된채로 개발되지 않고, 너무 많은 의존관계를 가지고 있는 것은 아닌지, 즉 설계가 잘못된 것은 아닌지 생각을 해봐야한다고 생각한다