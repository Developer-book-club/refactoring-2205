# CH 11. 질의 함수와 변경 함수 분리하기

# 11.1 질의 함수와 변경 함수 분리하기

## 요약

- 함수 내에서, 질의하는 부분과 변경하려는 부분이 분리 되어있지 않다면 적극적으로 분리하자
    - 재사용성의 측면이나, 코드 읽기 쉬워진다

## 중요 내용

- 겉보기 부수효과가 전혀 없이 값을 반환해주는 함수를 추구해야 한다.
- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. … 중략 … 질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다'는 규칙을 따르는 것이다.

## 내 생각

- 무조건적 적으로 분리할 필요는 없지만, 나누었을 때 분명히 이득이 있다고 생각한다 재사용하기 좋아지고, 코드 읽기 편해진다
- 책에서 말한 것 처럼 겉보기 부수효과에 대해서, 변경하려는 함수에만 신경쓸 수 있다

# 11.2 함수 매개변수 화 하기

## 요약

- 비슷한 로직이 반복되는 함수가 복수개 있을 때, 변화하는 부분과 그렇지 않은 부분을 파악하여서 일반화된 함수로 추출할 수있도록 하자

## 중요 내용

- 두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다.

## 내 생각

- 꼭 리팩토링 패턴으로 분류하지 않더라도, 무의식적으로 많이 사용하는 패턴이다 비슷한 로직이 있다면, 불필요하게 각각 생성하지 말고, 하나의 공통적인 로직을 다룰 수 있는 함수로 만들어서 활용하자

# 11. 3 플래그 인수 제거하기

## 요약

- 플래그 인수는 코드 읽는 사람에게 이득이 되는게 아닌, 작성하는 사람에게 이득이 되는 방향이다

## 중요 내용

- 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다
- 내가 플래그 인수를 싫어하는 이유가 있다. 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워지기 때문이다
- 특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다

## 내 생각

- 내 코드에도 플래그 인수를 사용하는 경우가 많다 다 대개 내 코드를 편하게 작성하기위한 방법으로 활용했던 것으로 기억한다 내 편의가 아닌 코드 읽는 사람의 편의를 위해서, 플래그 인수를 쓰는 대신 함수역할을 명확히 드러낼 수 있게 하는 방법을 더 고민해보자
- 쉬운 구현을 위해서 플래그 인수를 사용하더라도, 이후 리팩토링을 반드시 고려하자

# 11.4 객체 통째로 넘기기

## 요약

- 레코드에서 값 두어 개 가져와서 인수로 넘기는 경우에, 객체를 통째로 넘기고, 꺼내서 쓰도록 해보자

## 중요 내용

- 하나의 레코드에서 두어 개를  가져와 인수로 넘기는 코드를 보면, 나는 그 값들 대신 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다.
- 레코드를 통째로 넘기면 변화에 대응하기 쉽다.

## 내 생각

- 이 리팩토링 기법은 상황에 따라서 적절히 사용할 필요가 있다고 생각한다. 객체를 통째로 넘기는게 유연하게 쓸 수 있다는 장점이 분명히 있지만, 굳이 필요 없는 값 까지 포함시켜서 넘길 필요는 없기 때문이다
- 그래서 나의 경우는 1개~ 2개 정도만 필요할 때는 객체를 넘기지 않고, 풀어서 넘기는 편이다 상황에 따라서 다르게 조치하는게 필요할 것 같다

# 11.5 매개변수를 질의 함수로 바꾸기

## 요약

- 매개변수로 전달되는 값이 피호출자의 SRP 원칙을 어기지 않고 의존되지 않는다면, 이 리팩토링을 충분히 활용할 수 있다

## 중요 내용

- 매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다.
- 피호출 함수가 스스로 쉽게 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다. 이런 함수를 호출할 때 매개변수의 값은 호출자가 정하게 되는데, 이 결정은 사실 하지 않아도 되었을 일이니 의미 없이 코드만 복잡해질 뿐이다
- 매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다. 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때다. 즉, 해당 함수가 알지 못했으면 하는 프로그램 요소에 접근해야 하는 상황을 만들 때다.

## 내 생각

- 어떤 값을 매개변수로 넘겨 줄 것인가에 대해서 매번 코드 작성할 때 마다 고민하곤 한다. 굳이 매개변수를 넘겨줄 필요가 없다면, 질의함수로 피호출자 함수에 만드는 편이다
- but, 모든 경우에 쓸 수 있는 것은 아니다  함수 내부의 성격이 다른 의존성을 가진 것들은 질의함수로 바꾸게 되면 의존성을 심으면서, 함수의 SRP 원칙도 어기게 된다

# 11.6 질의 함수를 매개변수로 바꾸기

## 요약

- 매개변수로 전달되는 값이 피호출자의 SRP 원칙을 어긴다면, 매개변수로 넘겨주자

## 중요 내용

- 이런 상황 대부분은 코드의 의존 관계를 바꾸려 할 때 벌어진다.

## 내 생각

- 11.5와 반대되는 내용인데, 위에서 말한 것처럼 매개변수로 전달되는 값이 피호출자의 SRP 원칙을 어긴다면, 피호출자 함수 내에 코드를 두는 것보다는 외부로 부터 주입해주는 형태로 매개변수로 넘겨주는 것이 좋다고 생각한다

# 11. 7 세터 제거하기

## 요약

- 세터가 굳이 필요없다면, 세터를 제공해서 수정가능성을 만들지 말자

## 중요 내용

- 세터 메서드가 있다고 함은 필드가 수정될 수 있다는 뜻이다.
- 세터 제거하기 리팩토링이 필요한 상황은 주로 두 가지다.
    1. 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다.
    2. 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때다. 즉, 해당 세터들은 처음 생성할 때만 호출되리라 가정한다

## 내 생각

- 일반적인 객체의 경우에 set을 두는 것은 설계적으로 옳지 않을 수 있다 외부에 필드를 드러낸다는 측면에서도 그리좋진 않다 but, django orm 을 쓰는 경우에 한가지 필드에 대한 값 수정이 필요할 때는 어쩔수없이 setter 를 두게 되었다
- 이 챕터에서는 세터메서드를 없앰으로써, 객체 생성 후에는 수정되지 않길 원한다는 의도를 드러내주길 원하는데 반대로, 필요한 경우가 있다면, 적극적으로 드러나도록 해주어야 한다고 생각한다

# 11.8 생성자를 팩터리 함수로 바꾸기

## 요약

- 이것 저것 번거롭게 생성자 쓰기 보다는 팩토리 함수를 쓰자

## 중요문장

- 가령 자바의 생성자는 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다
- but, 팩토리 함수에는 이런 제약이 없다

## 내 생각

- 팩토리 함수를 왜 사용해야하는지에 대한 설명이 좀 부족한 것이 아쉽다
- 책에서는 생성자 정의 할 때 이런 저런 제약이 존재하고, 이것이 번거롭기 때문에 좀 더 유연하게 쓸 수 있는 팩토리 함수를 추천하는 것으로 보인다
- 디자인 패턴에 대한 이해 부족으로 여기서 저자가 말하는 내용을 온전하게 다 이해하고 있지 못하다 팩토리 패턴에 대해서도 이참에 보도록 하자

# 11.9 함수를 명령으로 바꾸기

## 요약

- 함수 자체 내부 로직이 길고 하는 일이 많을 때, 명령 객체로 변경 하면 캡슐화를 진행하면서 코드를 클래스로 응집성 높게 관리할 수 있다

## 중요문장

- 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체르 가리켜 명령 객체 혹은 단순히 명령이라 한다.
- 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다.

## 내 생각

- 이 패턴은 긴 함수 코드를 내부에서 여러개의 책임으로 분리된 명령 클래스로 변경하는 것을 말한다 함수 내부에서 하는 일이 많고, 캡슐화해서, 하나의 실행을 담당하는 인터페이스만 공개하고 싶을 때 사용하면 좋을 것 같다
- 개인적으로 이 패턴을 많이 쓰진 않지만, 책에서 말한 유연하게 함수를 제어하고 표현하는 장점을 봤을 때, 함수가 커질 때 쓰면 좋을 것 같다

# 11.10 명령을 함수로 바꾸기

## 요약

- 함수가 복잡하지 않다면 명령 객체를 만드는 것은 사치일 수 있다

## 중요 문장

- 명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다. 구체적으로는 큰 연산 하나를 여러 개의 작은 메서드로 쪼개고 필드를 이용해 쪼개진 메서드들끼리 정보를 공유할 수 있다.
- 명령의 이런 능력은 공짜가 아니다. … 중략 … 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는게 낫다

## 내 생각

- 당연하게도 함수 내부가 복잡하지 않고 간단한 연산으로 이루어져 있다면 굳이 명령객체로 만들 필요가 없고 오히려 낭비로 볼 수 있다 복잡하다고 느낄 때만 사용하도록 하자

# 11.11 수정된 값 반환하기

## 요약

- 데이터 수정 흐름을 잘 파악하기 위해서, 데이터를 수정하는 함수가 있을 때, 그 수정된 값을 반환하도록 하자

## 중요 문장

- 데이터가 어떻게 수정 되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나다.
- 데이터가 수정하는 흐름과 코드의 흐름을 일치시키기가 상당히 어렵다. 그래서 데이터가 수집된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다
- 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다.
- 리팩토링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다.

## 내 생각

- 코드리뷰를 하면서 가장 보기 힘든 것이 데이터가 수정되는 것을 계속 집중해서 추적해 나가는 것이다 책에서 나온대로, 데이터 수정 흐름과 복잡한 코드흐름을 같이 보다보면 코드가 헷갈리고 제대로 디버깅 하지 못하는 경우가 있다
- 의식하고 코드를 작성하진 않았지만, 변수를 갱신하는 함수를 만들 때, 반환 값으로 해당 변경된 변수를 넘겨주는 것은 무의식적으로 계속 하고 있었는데, 확실히 코드 흐름 속에서 데이터 수정 흐름을 놓치지 않게 할 수있는 좋은 방법이라고 생각하고, 반대로 하지 않았을 때, 코드흐름이 복잡할수록 파악하기 힘들었던것 같다.

# 11.12 오류 코드를 예외로 바꾸기

## 요약

- 예외를 아끼지 말고 예상치 못한 행동이 있을 때 적극적으로 사용하자

## 중요 문장

- 예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘이다.
- 예외는 정교한 메커니즘이지만 대다수의 다른 정교한 메커니즘과 같이 정확하게 사용할 때만 최고의 효과를 낸다.
- 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다. 달리말하면 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.

## 내 생각

- 예외는 예상치 못한 행동이 있을 때, 더 적극적으로 사용될 필요가 있다
- 특히 동적타이핑 언어의 경우에 예외를 제때 발생시켜주지 않으면 문제가 있음에도 문제를 알아차리지 못한 채로 서비스가 동작하게 만들 수도 있기 때문에 위험하다
- 서비스를 죽지 않게 하기 위해서 예외를 제 때 써주지 않는다면, 상처가 있을 때 바로 인지해서 치료하는게 아닌, 그냥 눈에만 안보이게 살짝 가려서 인지못하게 하는 것과 비슷하다 문제가 있다면 바로 드러나도록 예외처리가 필요하다

# 11.13 예외를 사전확인으로 바꾸기

## 요약

- 굳이 예외를 발생시키지 않은 곳 까지 예외라고 간주해서, 오남용하지 말고 정말로 예외라고 판단되는 것에서 사용해야 한다

## 중요 문장

- 오류 코드를 연쇄적으로 전파하던 긴 코드를 예외로 바꿔 깔끔히 제거할 수 있게 되었으니 말이다
- 예외는 ‘뜻밖의 오류' 라는 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.

## 내 생각

- 예외를 적극적으로 발생시켜야하는 것도 맞지만, 또 너무 오남용했을 때는 코드가 읽기 힘들어 질 수 있다
- 이 부분에서는 어렵게 try~catch로 exception을 잡아내려 하지말고, 사전확인으로 처리할 수 있다면, 사전확인 기법으로 처리하는 것을 말하고 있다
- 이렇게 가능한 이유는 예상치 못한 행동이 아닌, 조건을 체크하여서 확인이 가능하기 때문이다