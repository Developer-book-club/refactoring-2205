# 02 리팩토링 원칙

## 2.1 리팩터링 정의
[명사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하기 쉽도록 내부 구조를 변경하는 기법
[동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.
따라서 리팩터링하는 동안에는 코드가 항상 정상작동하기 떄문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

누군가 "리팩터링하다가 코드가 때져서 며칠이나 고생했다"라고한다면 십중팔구 리팩터링 한 것이 아니다.

겉보기 동작 === "사용자 관점"에서 달라지는 점이 없어야 한다.

ex) 리팩터링과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것.

## 2.2 두개의 모자
리팩토링할 때와 기능추가 할 때의 간격이 10분남짓한 짧은 시간이더라도 현재 자기가 하는 행동이 무엇(기능추가, 리팩토링)인지 정확히 인식해야 한다.

왜? -> 아마 한가지 컨셉에 집중하는게 코드 효율이 좋아서일지 모르겠다.

## 2.3 리팩터링하는 이유
### 1. 소프트웨어 설계 좋아짐
아키텍처를 충분히 이해하지 못한 채 단기 목표만 수정하다 보면 기반 구조가 무너지기 쉽다.

>요즘 많이 공감하는 문구인 것 같다.
처음에 이런 메소드를 재활용해야지 저런 구조를 똑같이 해야지 생각했던 것들이 나중에 개발하다보면 또 까먹어서 다시 개발하고 있다.
불과 3일전에 했는데도 기억은 나지만 다시 파악하는게 늦어지니까 그냥 새로만드는게 더 빨라서 중복코드를 만들고 있는 모습이 흔했다.
뭔가 더 와닿는것 같다.


>
그럼 고민은 어떻게하면 해당 메소드를 쉽게 참조할 수 있을까, 어디에 모아두어야 할까?


코드만 봐선 설계를 파악하기 어려워진다.
코드만으로 설계를 파악하기 어려워질 수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더울 빨라진다.

반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

코드량이 줄면 수정하는데 드는 노력은 크게 달라진다.

> 사수랑 이야기 했을때, 코드량이 줄어도 수정하기 어려운 코드는 지양해야한다고 한다.
>
수정하기 쉬운코드와 중복코드가 적어 수정하기 쉬운코드, 
겹치지 않을 영역같지만, 가끔 프론트코드에선 겹치곤하는것 같다.

### 2. 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 대화와 같다.
컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.

프로그래밍은 결국 내가 원하는 바를 정홯기 표현하는 일이다.

문제는 프로그램을 동작시키는 데만 신경쓰다 보면 
나중에 그 코드를 다룰 개발자를 배려하지 못한다는데 있다.

코드를 일해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야ㅕ 한다.

잘 작동은 하지만 이상적인 구조는 아니 코드가 있다면, 잠깐 시가능ㄹ 내서 리팩터링해보자.
그러면 코드의 목적이 더 잘 드러나게, 다시말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.

기억할 필요가 있는 것들은 최댜한 코드에 담으려고 한다.

### 3. 버그를 쉽게 찾을 수 있다.
리팩터링하면, 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.

### 4. 프로그래밍 속도를 높일 수 있다.
지금까지 제시한 장점을 한 마디로 정리하면 다음과 같다.
리팩터링하면 코드 개발 속도를 높일 수 있다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.

모듈화가 잘 되어있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.

설계 지구력 가설(Design Stamina Hypothesis)

## 2.4 언제 리팩토링?
저자: 1시간 간격으로 리팩터링

### 3의 법칙
1. 처음엔 그냥 한다.
2. 비슷한 일을 2번째로 하게 되면, 일단 계속한다.
3. 3번째 같은 일을 하게 되면 리팩터링한다.


### 1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

이 시점에 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질만한 부분을 찾는다.

가령 내 요구사항을 거의 만족하는 메서드지만, 리터럴값 몇 개가 방해되는 함수가 있을 수 있다.
함수를 복제해 사용해도 되지만, **함수 매개변수**화하기 를 적용한다.
그러고나면 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면 된다.
>11.2 함수 매개변수화하기
Before
```javascript
function temPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1);
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05);
}
```
After
```javascript
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor);
}
```
두 함수의 로직이 아주 비슷하고 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수로 하나로 합쳐서 중복을 없앨 수 있다.
이렇게 하면 매개변수 값만 바꿔서 여러곳에서 쓸 수 있으니 함수의 유용성이 커진다.

> 하지만 이와같은 수정은 매개변수가 늘어난다는 단점이 있다.
매개변수가 많아질 수록 어떤 값을 추가해야 한다는, 추가해아하는 데이터도 기억해야한다는 족쇄가 수반되기 때문에, 이런 수정은 얼마나 같이 붙어다니는지 역시 중요한 것 같다.

버그를 잡더라도 마찬가지,
오루를 일으키는 코드가 세곡에 복제되어 퍼져있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.

또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 ㄷ꼬여서 생기는 오류를 크게 줄일 수 있다.

> 질의 코드란?
getSomething();

> 갱신로직이란?
updateSomething()

이처럼 준비를 위한 리팩터링으로 상황를 개선해놓으면, 버그가 수정된 상태가 오래 지속될 가능성을 높이는 송시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 도 있다.

>정리: 준비를 위한 리팩터링
"**새로운 기능을 추가하기 전 리팩토링**"
- 성격이 다른 코드가 있는지(질의코드, 갱신로직)
- 중복코드 등


### 2. 이해를 위한 리팩토링: 코드를 이해하기 쉽게 만들기
코드를 수정하려면, 먼저 그 코드가 하는 일을 파악해야 한다.

나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 필랙터링 할 여지는 없는지 찾아본다.

조건부로직의 구조가 이상하지 않은지
함수 이름을 잘못 정해서 실제로 하는 일을 파악하는게 시간이 오래걸리지는 않은지


워드커닝햄: 리팩터링하면, 
머리로 이해한 것을 코드에 옮겨 담을 수 있다.
그런 다음 수정한 코드를 테스트해보면, 내 생각이 맞았는지 확인할 수도 있다.

내가 이해한것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.

코드가 깔끔하게 정리되면 보이지 않던 설계가 눈에 들어오기 시작한다.

### 3. 쓰레기 줍기 리팩터링
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 ㅣㅇㄹ은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
이것이 이래를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.

항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.
조금씩 개선하다 보면 결국 문제가 해결될 것이다.
리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.

### 4. 계획된 리팩터링과 수시로 하는 리팩터링
앞의 것들: 기회가 될 떄만 진행한다.

리팩터링은 눈 앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다.
리팩토링은 프로그래밍과 구분되는 별개의 활동이 아니다.

리팩터링은 보기싫은 코드도 해야하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

나는 코드를 작성할 때마다 적절히 타협한다.
예컨대 매개변수화하거나 개별 함수로 나누는 기준을 정한다.
어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다.

이렇게 상황이 변해 기준을 변경해야할 때 코드가 이미 깔끔하다면 리팩터링하기가 더 쉽다.

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 깅ㄹ일 수 있음을 안다.

그렇다고 계획된 리팩터링이 무조건 나쁠다는 말은아니다.

그동안 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드 베이스를 개선할 필요가 있다.

한편 정기적으로 리팩터링하더라도 어떤 문제는 팀우 ㅓㄴ 여럿이 달령들어야 할 정도로 곪아갈 수 도 있다.
하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야한다.
리팩터링 작업 대부분은 드러나지 않게 기회가 될 떄마다 해야한다.

git에서 리팩터링 커밋과 기능추가커밋을 분리해야하는 조언을 들은 적이 있다.
이렇게 할 떄의 큰 장점은 2가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는 것이다.

나는 이 견해에 완전히 동의하지는 않는다.
리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 ㅁ낳기 떄문에 굳이 나누는 것은 시간낭비이 ㄹ수 있다.

커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 팀에 적합한 방식을 실험을 통해 찾아내야한다.

### 5. 오래걸리는 리팩터링
오래 걸리는(최소 몇주) 리팩터링이 존재한다.
- 라이브러리를 새로운 것으로 교체
- 일부 코드를 컴포넌트로 대체
- 골치아픈 의존성 정리

이런 상황에서라도  팀 전체가 리팩터링에 매달리는 데는 회의적이다.

그보다 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 떄가 많다.
누구든지 리팩터링해야할 코드와 관련한 작업을 할게 될 떄마다 원하는 방향으로 조금씩 개선하는 식이다.

예컨대 라이브러리를 교체할 때는 기존 거ㅏㅅ과 새 것 모두를 포용하는 상인터ㅋ페이스 부터 마련한다.
기존 코드가 이 추ㅠ상 인터페이스를 호출하도록 만들고나면 라이브러리를 훨신 쉽게 교체할 수 있다.(이 전략을 추상화로 갈아타기라고한다.Branch By Abstraction)

### 6. 코드 리뷰에 리팩터링 활용하기
코드리뷰는 정기적으로 수행하는 것이 좋다.
코드 리뷰는 개발팀 전체에 지식을 전파하는 게 좋다.
경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.

대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는데도 도움된다.
깔끔하 코드를 작성하는데에도 굉장히 중요하다.
내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다.

자신이 하는 일에 익숙하지 않은 사람의 관점에서 바라보기란 누구에게나 어렵기 때문이다.

다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.

이처럼 서로의 기여가 일을 더욱 편하게 만들어주므로 나는 기회가 닿는 대로 코드리뷰ㅜ를 한다.

리팩터링은 다른 이의 코드를 리부ㅠ하는데도 도움된다.

리팩터링을 활용하기 전에는 코드를 읽고 그럭저럭 이해한뒤 몇 가지 개선사항을 제시했다.

지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다.


쉽다면 실제로 리팩터링한다.
이 과정을 몇 번 반복하면 내가 떠올리 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다.

머리로만 상상하는게 아니라, 눈으로 직접 확인하는 것이다.

그러다 보면 리팩터링해보지 않고는 도적히 떨올릴 수 없던 한 차원 놓은 아니이더가 또로르기도 한다.

리팩터링은 코그 리뷰ㅜ의 결과를 더 구체적으로 도출하는데에도 도움된다.
개선안들을 제시하는데서 그치지 않고 그중 상당수를 즉시 구현해볼 수도 있기 떄문이다.
코드 리뷰를 이런 식으로 진행하면 훨씬큰 성취감을 맛볼 수 있다.

### 7. 관리자에게 뭐라고 말할까?
개발자는 프로다.
개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다.

새 함수를 추가하려는데 현재 설계가 적합하지 않다면
먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다.

버그를 수정하려면 현재 소프트웨어의 작동 방식을 이해해야한다.

### 8. 리팩터링하지 말아야 할 때
지저분한 코드를 발견해도 굳이 수정할 필요가 없다면, 리팩터링하지 안흔다.
외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.

내부 동작을 이해해야할 시점에 리팩터링해야 제대로된 효과를 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는것이 더 쉬울 떄도 리팩터링하지 않는다.
사실 이런 결정을 내리기는 쉽지 ㅇ낳ㄴ다.
뛰어난 판단력과, 경험이 뒷받침되어야한다.



## 2.5 리팩터링 시 고려할 문제

### 1. 새 기능 개발 속도 저하
리팩터링의 궁극적인 목적은 개발속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.


나는 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게할 수 있다고 홗신한다.

그래서 새 기능을 추가해야할 떄, 구현해지기 편해질 것 같은 리팩터링의 경우 주저하지 않는다.

한번 본 문제의 경우도 리팩터링부터 하는 편이다.


반면 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 하지 않는다.
때로는 어떻게 개선해야할 지 명확히 떠오르지 않아 미루기도 한다.

대부분은 리팩터링을 더 자주하도록 노력해야한다.
건강한 코드의 위력을 충분히 경험해보지 ㅇ낳고서는 코드베이스가 건강할 떄와 허약할 떄의 생산성 차이를 체감하기 어렵다.

코드 베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 위워서 보갖한 새 기능을 더 빨리 추가할 수 있다.

사람들이 범하는 가장 위험한 오류는 리팩터링을 '클린코드'나 '바람직한 엔지니어링 습과'처럼 도덕적인 이유로 정당화하는 것이다.
리팩터링의 본질은 코드베이스를 예쁘게 꾸미는데 있지 않다.

오로지 경제적인 이유료 하는 것이다.

리팩터링은 개발 기간을 단축하고자 하는것이다.
기능 추가시간을 줄이고, 거그 수정시간을 줄인다.


스스로 그렇게 인식하는데 그치지 말고 다른 사람과 대화할 떄도 이 점으 명심해야한다.

이래야 개발 진행 그래프에서 '좋은 설계'곡선을 더 많이 볼 수 있다.

### 2. 코드 소유권
코드 소유권이 나뉘어 있으면 리패터링에 방해가 된다.


### 3. 브랜치
어떤 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리스할 떄가 돼서야 마스터에 동합하는 경우가 많다.


하지만 이런 기능ㅇ 브랜치 방식에는 단점이 있다.
독립 부랜치로 작업하는 기간이 길어질 수록 작업 결과를 마스터에 통합하기가 어려워진다.

나는 머지와 통합을 명확히 구분한다.

마스터브랜치로 머지하는 작업은 단방향이다.

개인 브랜치만 바뀌고 마스터는 그대로다.

반면 통합은 마스터를 개인 프랜치로 가녀와 작업한 결과를 다시 마스터에 올리는 양방향 처리르 뜻한다.

그래서 마트서와 개인 브랜치 모두 변경된다.

이처럼 머지가 복잡해지는 문제는 기능별 브랜치들이독립적으로 개발되는 기간이 길어질 숭록 기하급수적으로 늘어난다.


저자는 지속적 통합 또는 트렁크 기반 개발(TBD)라하여 하루에 최소 한 번은 마스터와 통합한다.

CI를 적용하기 위해선, 마스터를 건강하게 유지하고, 
거대한 기능을 잘게 쪼개는 법을 배우고,
각 기능을 끌 수 있는 기능 토글을 정용해 완료되지 ㅇ낳은 기능이 시스템 전체를 망치지 않도록 해야한다.

### 4. 테스팅
핵심은 오류를 재빨리 잡는데 있다.
코드의 다양한 ㅈ측면을 검사하는 테스트 스위트가 필요하다.
달리말해 리팩터링하기 위해서는 자가 테스트코드를 마련해야 한다는 뜻이다.

물론 테스트에 어느 정도 노력을 기울여야 하는 것은 사실이지만, 효과는 상당하다.
자가 테스트코드는 리팩터링을 할수 있게 해줄뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.

실수로 만든 버그그 빠르게 찾아서 제거할 수 있기 때문이다.

이때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는데 있다.

### 5. 레거시 코드
레거시 시스템을 파악할 떄 리팩터링이 공장히 도움된다.
함수이 이름 바로잡기, 어설픈 프로그램 구문을 매끄럽게 다듬고,
하지만 테스트가 없는 리팩터링 매우 위험

그렇기에 테스트 보강 필요
하지만 이 또한 매우 어렵

결론: 쉽게 해결할 방법은 없다.
책: 레거시 코드 활용 전략(에이콘, 2018) 추천
'프로그램에서 테스트를 추가할 틈새를 찾아 시스템을 테스트해야 한다'

이런 틈새를 만들기 위해 리팩터링이 활용된다.
감내해야할 위험

단번에 바꾸기 보다는 내가 작업하는 영역을 조금씩 이전보다 새건하려고하는것(캠핑 규칙)

코드를 자주 훑게되는 부분 -> 리팩터링 했을 때 개선이 큰 부분

### 6. 데이터 베이스
진화형 데이터베이스 설계, 데이터베이스 리팩터링
'커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는데 있다.'

다른 리팩터링과 마찬가지로 이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.


## 2.6 리팩터링, 애키텍쳐, 애그니(YAGNI)

리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다.
이전: 코딩을 시작하기 전에 소프트웨어 설계와 아키텍처를 어느정도, 심지어 거의 완료해야 한다고 배움, 코드로 작성된 뒤로는 아키텍처를 바꿀 수 없고 부주의로 인해 부패할 일만 남았다.

리팩터링 이후:수년 동안 운영되던 소프트웨어라도 아키텍처를 대폰 변경할 수 있었다.
리팩터링으로 기존 코드의 설계를 개선할 수 있다.
레거시 코드는 변경하기 어려울 떄가 많다., 테스트가 없다면 더더욱 그렇다.


> 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는데 있다.


코딩 전에 아키텍처를 확정지으려 할 떄의 대ㅠ표적인 문제는 소프트웨어 요구사항을 사전에 모두 파ㅇㄱ해야한다는 것이다.

하지만 막상 해보면 실현할 수 없는 목표일 때가 많다.
우리는 소ㅍ트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를ㄹ 알게 되는 경우가 허다하다.

리팩터링 외의 방법: 유연성 메커니즘
다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다.

하지만 이 방법은 큰 비용이 필요하다.
당장에 쓰임에 비해 함수가 너무 복잡해진다.
그리고 예상과 다르게 사용되거나 아예 사용하지 않을 수 잇다.
이런 경우가 자주 일어날 수록 유연성 메커니즘이 오히려 변화에 대응하는 능력을 ㅈ떨어뜨릴 때가 대부분이다.

리팩터링을 활용한다면, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
단, 이 요구ㅅ를 멋지게 해결하도록 설계한다.
ㅈ;ㄴ행하면서 사용자의 요구사항을 더 잘 이해하게 되면, 아키텍처도 그에 맞게 리팩터링해서 바꾼다.

그 과정에서 (작고 멋진 이름의 함수처럼) 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유ㅜ연성 메커니즘은 반드시 검증을 거친 후에 추가한다.

> 소프트웨어의 복잡도에 지장을 주는 메커니즘과 그렇지 않은 메커니즘은 어떤 것이 있을까?

리팩터링을 미루면 나중에 얼마나 어려월질지를 가늠해보면 파판단에 도움이된다.

이런식의 설계: 간결한 설계, 점짖ㄴ적 설꼐, YAGNI라 한다.
YAGNI가 소프트웨어 아키텍처에 대해 전혀 고려하지 말라는 뜻은아니다.
아키텍처와 설계를 개발 프로게사ㅡ에 녹이는 또 다른 방식이며, 리팩터링의 뒷받침없이는 효ㅕ과를 볼 수 없다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스
리팩터링이 잘 되는 환경
자가 테스트 코드 + 지속적 통합 + 리팩터링

제대로된 애자일을 적용하기 위해선 팀의 역량과 열정이 뒷받침 되어 프로세스 전반에 리팩터링이 자연스럽게 녹아들어야한다.

1. 자가 테스트 코드

2. 지속적 통합
각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링을 할 수 잇어야한다.
지속적 통합을 통해 각자가 수행한 리팩터링 결과를 빠를게 동료와 공유할 수 잇다.
그래서 불필요한 코드의 사용을 줄이고, 문제가 생겼을 떄 빠르게 알아차릴 수 있다.

위 3조건 충족되면, YAGNI 설계 방식으로 개발을 진행할 수 있다.

리팩터링과 선수조건들이 YAGNI를 위한 토대가 되고, 
YAGNI로 인해 리팩터링을 더욱 쉽게할 수 있다.
수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기 훨씬 쉽기 떄문이다.

이런 메커니즘이 적용되면 소프트웨어의 수정을 릴리즈하는 시간이 단축되어
좋은 아이디어를 프러덕션 코드로 반영하는 시간을 엄청나게 단축할 수 있어 고객에게 더 나은 서비스를 제공할 수 잇다.

어떤 접근법이던, 충분한 연습과 실력이 뒷받침 되어야 한다.

## 2.8 리팩터링 성능
'우선 성능 생각말고 리팩터링, 이훈 문제가 생기면 전문 프로파일 도구를 이용해 문제의 부분만 수정'

## 2.9 리팩터링 유래
스몰토크..?

## 2.10 리팩터링 자동화
vscode는 충분히 좋은 리팩토링 도구를 제공하는 듯?
구문트리로 해석해 변경하는 함수의 모든 부분을 알아서 수정해줌
+ typescript를 썼기에 좋다.

## 2.11 더 알고싶다면..


# 코드에서 나는 악취(패턴)

적용 방법을 아는것과 제때 적용할 줄 아는 것은 다르다.

'리팩터리을 언제 시작'하고, '언제 그만할지'를 판단하는 일은 중요

언제 리팩터링이 필요한가?
-> 악취가 날때(안조아보이는 패턴을 발견할 때)

언제 멈춰야하는가?
-> 경험, 직관

이 책의 사용방법 부록B를 보며 내 코드의 악취를 찾는다.
6~12장에서 해결방법을 찾아 도움이 될만한지 고민한다.


## 3.1 기이한 이름
코드든 단순 명료하게
함수, 변수, 모듈, 클래스

자주 쓰이는 리팩터링
- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기

마땅한 이름이 떠오르지 않는다. -> 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.
이름을 정의하다보녕, 코드가 훨씬 간결해 질 때가 많다.


## 3.2 중복 코드
함수가 완전히 동일하진 은데 비슷하다면 
문장슬라이드를 통해 비슷한 부부능ㄹ 한곳에 모아두고 추출

## 3.3 긴 함수
오랜 기간 잘 활용되는 프로그램 -> 짧은 함수로 구성
짧은 함수들로 구성된 코드베이스를 얼핏 풅으면 연산하는 부분이 하나도 없어 보인다.(함수형 프로그래밍..?)

코드가 끈없이 위임하는 방식으로 작성되어 있기 때문
(좋은 건가..?)
> 끝없이 위임하는 코드(좋다는)가 어떤 방식인지 잘 모르겠다.

간접 호출의 효과
- 이해하고
- 공유하고
- 선택하기 쉬워진다

함수가 하는 일을 파악하기 위해 왔다갔다 하면 힘들다.

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법: 좋은 이름

좋은 이름을 짓기 위해서도 훨씬 적극적으롷 ㅏㅁ수를 쪼개야 한다.

우리는 주석을 달만한 부분은 무조건 함수로 만든다.
함수 본문에는 주석으로 설명하려던 코드가 담기고, 하뭇 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.

> 의도가 드러나게 적는다. 생각보다 쉽지 않았던거 같다.


핵심은 함수의 길이가 아니라, 함수의 의도와 구현코드의 괴리가 얼마나 큰가이다.

즉 무엇을 하는지를 코드가 잘 설명해주지 못할 수록 함수로 만드는게 유리하다.

함수를 짧게 만드는 작업의 99% => 함수 추출하기

함수가 매개변수와 임시변수를 많이 사용하다 
-> 임시변수를 질의 함수로 바꾸기, 
> 임시변수와 질의함수는 어떤 부분이 달라서 질의함수가 더 좋은건가?
내가 보기엔 비슷한거 같은데..

-> 매개견수 객체 만들기
-> 객체 통째로 넘기기
로 매개변수의 수를 줄일 수 있을 것이다.

이래도 매개변수와 임시변수가 많다면, 함수를 명령으로 바꾸기를 고려

추출할 코드 덩어리를 찾는 방법
1. 주석
2. 조건문이나 반복문
조건문 
-> 조건문 분해하기 
-> switch의 case대로 함수 추출하기
-> 조건문을 다형성으로 바꾸기

반복문
-> 반복문 쪼개기

## 3.4 긴 매개변수 목록
매개변수 목록이 길면 그 자체로 이해하기 어려울 때가 많다.
종종 다른 매개변수에서 값을 얻어올 수 잇는 매개변수가 있는데
이런 매개변수는 매개변수를 질의 함수로 바꾸기로 제거할 수 있다.

사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면
객체 통째로 넘기긱를 적용해 원본 데이터 구조를 그대로 전달한다.

항상 함께 전달되는 매개변수들은 매개변수 객체 만들기를 적용한다.
함수의 동작방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애준다.
>before
```javascript
function setDimension(name, value) {
  if(name === 'hegiht') {
    this._height = value; 
    return;
  }
  if(name === 'width') {
    this._width = value;
    return;
  }
}
```
after
```javascript
function setHeight(value) {this._height = value; }
function setWidth(value) {this._width = value; }
```

## 3.5 전역 데이터
전역 변수
클래스 변수
싱글톤 
에서도 같은 문제가 야기된다.

> 공통 함수 export되는 함수와 다른점은 무엇일까?
비슷하게 작용될 수 있는 여지가 있는거아닌가?


이를 방지하기 위햇 우리가 사용하는 대표적인 리팩터링 은 
변수 캡슐화하기이다.
다른 코드에서 오렴ㄷ시킬 사능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.


이런 데이터를 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근으 통제할 수 있다.

더 나아가 접근자 햐ㅏㅁ수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 죽이는 것도 좋다.


## 3.6 가변 데이터
코드의 다른 곳에서는 다른 값을 기대한다는 사싱르 인식하지 못한 채 수정해버리면 , 프로그램이 오작동한다.

함수형 프로그래밍에서는 디에터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 밪ㄴ환한다는개념을 기보능로 삼고있다.

무분별한 데이터 수정에 따른 위험을 줄이은 방법
- 변수 캡술화하기
정해놓은 함수를 거쳐야만 값을 수정할 수있도록

- 변수 쪼개기
하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우

- 문장 슬라이드하기, 함수 추출하기
갱신로직은 다른 코드와 떨어뜨려 놓는 것이 좋다.

질의함수와 변경함수 분리하기
- api 만들때,

세터 제거하기
#### 파생변수를 질의 함수로 바꾸기(9.3)
>
before
```javascript
get discountedTotal() { return this._discountedTotal; }
set discount(aNumber) {
  const old = this._discount;
  this._discount = aNumber;
  this._discount += old - aNumber;
}
```
after
```javascript
get discountedTotal() { return this._baseTotal - this._discount; }
set discount(aNumber) { this._discount = aNumber }
```
파생변수: this._discountedTotal
질의함수: this._baseTotal, this._discount

여러 함수를 클래스로 묶기
여러함수를 변환함수로 묶기
 -> 변수를 갱ㅇ신하는 코드들의 유형범위를 클래스나 변환으로 제한한다.
 
 참조를 값으로 바꾹;
 -> 구조체처럼 내부 필드에 ㄷ[이터를 담고있는 변수라면
 
 내부필드를 직접 수정하지 말고 구조체를 통ㄷ째로 교체하는 편이 낫다
 
 ## 3.7 뒤엉킨 변이
 우리는 소프트웨어의 구조를변경하기 귀운 펴앹로 조직한다.
 
 코드를 수정할 떄는 시스템에서 고쳐야할 띡 힌 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.
 이렇게 할 수 없다면
 - 뒤엉킨 변경
 - 산탄총 수술
 2중 하나이다.
 
 뒤엉킨 변경은 단일 책임 원칙을 제대로 지켜지지 않을때 나타난다.
 
> 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때 발생

예컨데 지원해야할 데이터베이스가 추가될 때마다 함수 3개를 바꿔야하고,
금융 상품이 추가될 때마다 또다른 하뭇 3개를 바꿔야 하는 모듈이 있다면
뒤어잌ㄴ변경이 발생했다ㅡㄴ 뜻?


데이터베이스 연동과 금융 시ㅏㅇ품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 ㅠ프로그램이이 편하다.

그래야 무언가 수정할 때 해당 맥락의 코드만 이해해도 진행할 수 있다.
>
요즘 api는 hook폴더에
page는 template에
기능이 있는 컴포넌트는 module에
>
사실 이 정책도 프로젝트 전체에서보며ㅛㄴ 일관성이 많이 깨지는 원칙이다.
>
- 무언가를 수정할 떄 해당 맥락의 코드만 이해해도 진행할 수 있다.
- 독립된 모듈로 분리해야 프로그래밍이 편하다.

우리는 이렇게 분리하는 일이 중요함을 예전부터 알고 있었지만 나이를 먹어 요즘은 더 중요하게 됨

개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어렵고
소프트우 ㅣ에의 시스템의 기능이 변경되면서 이 경계도 끊임없이 움직이기 때문이다.

데이터베이스에서 데이터를 가져와 슴융상품로직에서 처리해야하는 일처럼 순차적으로 실행되는게 자연스러운맥락이라면,
다름 맥락에 필요한 데이터를 특정한 데이터 구조ㅓ에 담아 전달하게 하는 식으로 단계를 분리한ㄷ.

> 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.
(단계 쪼개기)

>전체 처리 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면,
각 맥락에 해당하는 적당한 모듀ㅜㄹ들을 만들어서 관련함수를 모은다.

그러면 처리 과정이 맥락별로 구분된다.

이때 여러 맥락의 일에 관여하는 함수가 있다면, 옮기기 전에 함수 추출하기 부터 수행한다.

|  | 뒤엉킨 변경 | 산탄총 수술 |
| - | - | - |
| 원인 | 맥락을 잘 구분하지 못함|(동일)|
| 해법 | 맥락을 명확히 구분|(동일)|
| 발생 과정(현상) | 한 코드에 섞여 들어감| 여러 코드에 흩뿌려짐|
| 해법(실제 행동) | 맥락별로 분리| 맥락별로 모음 |
## 3.8 산탄총 수술
이 냄새는 코드를 변경할 때마다 자잘하게 수정해야하는 클래스(컴포넌트)가 많을 떄 풍긴다.
> 즉 같이 있는게 더 수정하기 용이한데 뭐하러다가 그렇게 짧게짧게 나누었나 그 소리이다.

변경한 코드가 전반에 ㅍ퍼져있다면 찾기도 어렵고 꼭 수정해야할 곳을 지나치기 쉽다.

이렇때는 함ㅅ께 변경되는 재상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다.


비슷함 데이터를 다루는 함수가 많다면ㅇ 여러함수를 클래스로 묶기를 적용한다.

데이터구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환함수로 묶기를 적용한다.
> #### 여러 함수를 변환함수로 묶기(6.10)
before
```javascript
function base(aReading) {...}
function taxableCharge(aReading) {...}
```
after
```javascript
function enrichReading(argReading) {
  const aReading = _.cloneDeep(argReading);
  aReading.baseCharge = base(aReading);
  aReading.taxableCharge = taxableCharge(aReading);
  return aReading;
}
```

이렇게 묵을 함수들의 출력 괄를 묶어서 다음 단계의 로직으로 전달할 수 있다면 단계 쪼개기를 적용한다.

어설프게 분리된 로직은 함수 인라인하기나 클래스 인라인하기같은 인라인 리팩터링으로 하나로 함치는 것도 좋은 ㅏㅂㅇ법

코드를 재구성하는 중간과정에서는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

## 3.9 기능 편애
> 뒤엉킨 변경의 부분집합처럼 보인다.

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈뒤 영역 안에서 이뤄지는 상호작요ㅕㅇ은 최대한 늘리고
영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.

기능 편애는  어떤 함수가 자기가 속한 모듀ㅜㄹ의 함수나 데이터보다 
다른 모둘의 함수나 데이터롸 상호작용할 일이 더 많을 때 풍기는 냄새다.

해결:
이 함수가 같이 있고싶어하는 곳으로 보내주면 됨

때로는 함우의 일부분에서만 기능을 편애할 수 있다.
이럴 땐, 그 부부만 돍립함수로 ㅈ빼낸다음 원하는 모듈로 보내준다.

만약 함수가 사용하는 모듈이 다양하다며ㅛㄴ? 어느 모둘로 옮겨야할까?
가장 많은 데이터를 ㅍ포함한 모둘로 옮긴다.

함게 변경할 대상을 한데 모으는 것

데이터와 이를 활용하는 동작은 함꼐 변경행할 떄가 많지만 예외가 있다.
그럴 떄는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.


## 3.10 데이터 뭉치
몰려다니는 데이터 뭉치는 보금자리를 따로 만드렁줘야한다.

판별 망법
하나를 삭제했을 떄 나머지 데이터만으로는 의미가 없다면 객체로 환생하기 ㄹ갈망하는 데이터 뭉치

## 3.11 기본형 집착
ㅍ,로그래머 중에 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간)을 직접 정의하기 몹씨 꺼리는 사람이 많다.

이 냄새는 문자열을 다루는 코드에서 특히 흔하다.
> 정규식으로 validation체크를 하면 괜낳지 않가?

## 3.12 반복되는 switch문
조건부 로직을 다형성으로 바꾸기

## 3.13 반복문
반복문을 파이프라인으로 바꾸기

왜 탐탁치 않을까? > 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있지 못하기에

## 3.14 성의없는 요소
구조가 필요없는데(본문 코드를 그대로 쓰는것과 차이가 없는 경우) 구조를 사용했다면 해체한다.

>작은 단위의 함수, 의미를 같지 못한 함수
더해서 함수보다는 클래스나 모듈단위(컴포넌트 단위)에서 의미 없는 컴포넌트화를 가리키는것 같다.

## 3.15 추측성 일반호ㄴ
나중에 필요할 거야 라는 생각으로 당장은 필요없응 모든 종류의 후킹 포인트와 특이케ㅔ이스 처리 로직
(유연성 메커니즘..?)

ㅈ당장에 걸리적거리는 코드는 치워야한다.

- 하는 일이 거의 없는 추상 클래스 -> 계층 합치기
- 쓸데없는 위임하는 코드 -< 함수 인라인하기, 클래스 인라인하기
본문에서 사용되지 않는 매개변수 -> 함수 선언 바꾸기

추측성일반화 예시
- 테스트코드말고응 사용하는 곳이 없는 함수, 클래스

## 3.16 임시 필드
> 임시 변수의 그 처리가 비슷한듯 하다.
 -> 아니다. 객체를 생성하면 모두 채워져 있을꺼랏 애각해서란다.

특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
하지만 객체를 사용할 때 그 값이 모두 채워져 있으리라 기대하는게 일반적
따라서 코드를 이해하기 까다ㅇ로워지니다.
사용자는 해당 데이터가 존재하는 이유를 파악하는 머리를 싸매게 된다.

클래스 추출하기로 제 살곳을 찾아준다.
함수 옮기ㅣㄱ로 임시필드와 관련된 코드를 모조리 새 클래스에 몰ㅇ넣는다.


->> 특정 상황에서만 추가되는 컴포넌트가 있다.
이 컴포넌트와 관련된 코드 전부 독립적인곳으로 옮겨주자.

> #### 특이케이스 추가하기
before
```javascript
if(aCustomer === '미확인고객') customer = '거주자';
```
after
```javascript
class UnknownCustomer {
  ...
  get name() {return '거주자'};
}
```

## 3.17 메시지 체인
모습: 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금얻은 객체에 또 다른 객체를 요청하는 식으로 작업이 연쇄적으로 이어지는 코드를 말한다.
> dom 구조에서 특정 부모를 찾아가는 경우가 생각난다.

이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.

내비게이션 중간 단곌르 수정하면 클라이언트 코드도 수정해야한다.

이는 위임 숨기기로 해결한다.
>dom 부모찾기는
함수로 만들고, 의미있는 이름을 지으고 dom 메소드를 최대한 활용하는 방법이 있을 것 같다.
```javascript
const target = e.currentTarget
const selectValue = target.closest('tr').querySelector('select').value
```
ex) 
after()
animate()
append()
attachShadow()
before()
closest()

## 3.18 중개자
객체의 기능 캡슐화

위임이 자주 활용된다.
하지만 클라이언트가 모든 중개자를 알아야 할 필요는 없다.
중개자를 적절히 없애야한다.
중개자 제거하기(7.8)

## 3.19 내부자 거래
..
## 3.20 거대한 클래스
클래스 거대 -> 필드 수 많아짐
필드 수 많아짐 -> 중복 코드가 생기기 쉽다.

이럴 때 클래스 추출하기로 필드들 일부를 따로 묶는다.
ㅎ한 클래스안에 접두어나 접미어가 같은 필드들이 함계 추출ㅎㄹ 후보들이다.

코드량이 너무 많은 클래스 역시 중복 코드와 혼동을 일으킬 여지가 크다.
가장 간단한 해법은 그 클래스안에서 자체적으로 중복을 제거하는 것이다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

> 타입스크립트가 인터페이스와 같은 역할을 하고잇지 않은가 생각하고 있다.

## 3.22 데이터 클래스
데이터 게터/세터로만 이루어진 클래스
그저 데이터 저장용으로 쓰이다 보니,ㅏ 너무 깊이까지 함부로 다룰 떄가 많다.

최대한 public코드는 제거하고
변경하면 안되는 필드는 세터 제거하기를 하자.'

필요한 동작이 엉뚱한데 정의돼어 잇다는 신호일 수 있다.

하지만 불변필드는 굳이 캡귤화할 필요가 ㅇ벗다.
그냥 필드 자체를 공개해도 된다.

## 3.23 상속 포기
## 3.24 주석
주석을 남겨야 겠다면, 우석 주석이 필요없는 코드로 리팩터링해본다.

뭘 할지 모를 때라면 주석을 달아두면 좋다.
확실하지 않은 부분도 주석으로 남기자

코드를 지금처럼 작성한 이유를 설명하는 용도로도 좋다.

나중에 수정해야할 때 좋은 정보가 된다.

ㅜ 흐ㅓㄹ흐ㅓㅎㄹ허ㅛㅜㅛㅓㅛ뤄ㅛ구오
