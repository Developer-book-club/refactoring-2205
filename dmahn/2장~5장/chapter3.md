# 3. 코드에서 나는 악취

어떤 리팩터링 기법을 적용할지 모르겠다면 코드가 풍기는 매새가 무엇인지 찾자 그런 다음 6~12 장에서 찾아 읽고 그 냄새를 없애는 데 생각해본다.

- 기이한 이름
  - 이름만 보고도 무슨 일을 하고 어떻게 사용해야하는지 명확히 알수 있도록 신경써야한다.
  - 마땅히 이름이 떠오르지 않는다면 설꼐에 더 근본적인 문제가 숨어있을 가능성이 높다.
  - 함수선언 바꾸기 , 변수 이름 바꾸기 , 필드 이름 바꾸기
- 중복 코드
  - 코드구조가 여러곳에서 반복된다면 하나로 총합한다.
  - 하나를 변경할때 다른 곳에서 쓰인 코드 구조도 같이 바꿔줘야 되서 합치는게 좋다.
  - 함수 추출하기, 문장 슬라이드하기, 메서드 올리기
- 긴 함수
  - 함수는 길수록 이해하기 어렵다.
  - 함수 추출하기, 임시변수를 질의함수로 바꾸기, 매개변수 객체 만들기 , 함수를 명령으로 바꾸기, 조건문 분해하기 , 조건부 로직을 다형성으로 바꾸기, 반복문 쪼개기
- 긴 매개 변수 목록
  - 매개변수 목록이 길어지면 이해하기 어려워진다.
  - 매개변수를 질의 함수로 바꾸기, 객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기, 여러 함수를 클래스 묶기
- 전역 데이터
  - 변수 캡술화하기
- 가변데이터
  - 무분별한데이터 수정에 따른 위험을 줄이는 방법
  - 변수 캡슐화하기, 변수 쪼개기, 문장 슬라이드하기, 함수 추출하기. 즐의함수와 변경함수 분리하기, 세터 제거하기
    - 유효범위가 넓어질수록 위험이 커진다.
  - 여러함수를 클래스로 묶기 , 여러함수를 변환함수로 붂기, 참조를 값으로 바꾸기
- 뒤엉킨 변경
  - 응집성 높을때
  - 단일책임 원칙을 제대로 지켜지지 않을때 나타난다.
  - 금융상품이 추가될때 마다 또 다른 함수 네개를 바꿔야하는 모듈이 잇다면 뒤엉킨 변경이 발생했다는 뜻이다.
  - 단계 쪼개기, 함수 옮기기, 함수 추출하기 , 클래스 추출하기
- 산탄총 수술
  - 의존성이 높을때
  - 코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 때 풍긴다.
  - 함수 옮기기 , 필드 옮기기, 여러함수를 클래스로 묶기 , 여러함수를 변환함수로 묶기, 단계 쪼개기, 함수 인라인하기, 클래스 인라인 하기
- 기능 편애
  - 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을때
- 데이터 뭉치
  - 데이터 항목들 서너개가 여러 곳에서 항상 뭉쳐다닌다면 데이터 뭉치의 보금자리를 따로 마련해주어야한다.
- 기본형 집착
  - 자신에게 주어진 문제에 딱 맞는 기초 타입을 직접 정의하는 것을 꺼리는 사람이 많다.
  - 타입코드를 서브클래스로 바꾸기, 조건부 로직 다형성으로 바꾸기
- 반복되는 switch 문
  - 다형성이 널리 자리잡아서 단순히 switch 문을 썻다고 해서 자동으로 검토대상은 되지 않는다.
  - 똑같은 조건부로직이 여러곳에서 반복해 등장하는 코드에 집중해보자
- 반복문
  - 반복문을 파이프라인으로 바꾸기
- 성의없는 요소
  - 실질적으로 메서드가 하나뿐인 클래스도 있다. 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이었지만 어떤 사정으로 인해 그렇게 하지 못한 결과일 수 있다. 이런 프로그램요소는 고이 보내드리는게 좋다.
  - 함수 인라인하기, 클래스 인라인하기, 계층합치기
- 추측성 일반화
  - 나중에 필요할 거야라는 생각으로 당장은 필요없느 모든 종류의 특이 케이스 처리로직을 작성해둔 코드
  - 당장에 걸리적 거리는 코드는 눈앞에 치워버리자
- 임시필드
  - 특정 상황에만 값이 설정되는 필드를 가진 클래스도 있다.
- 메시지 체인
  - 메세지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또다른 객체를 요청하는 식으로 연쇄적으로 이어지는 코드를 말한다.
- 중개자
  - 위임이 지나쳐도 문제가 된다
  - 클래스가 제공하는 메서드중 절반이 다른 클래스에 구현을 위해 일하고 있다면 중개자를 제거하여 실제로 일을 하는 객체와 직접 소통하게 하자
- 내부자 거래
  -
- 거대한 클래스
  - 한 클래스가 너무 많은 일을 하고 있다면 필드수가 상당히 늘어난다.
  - 클래스에 필드가 많으면 중복코드가 생기기 쉽다.
- 서로다른 인터페이스의 대안 클래스
  - 클래스의 장점은 필요에따라 언제든 다른 클래스로 교체할수 있다.
  - 교체가 가능하려면 인터페이스가 같아야한다.
- 데이터 클래스
  - 데이터 필드와 게터 세터 메서드로 만 구성된 클래스를 데이터 클래스라한다.
  - 누가 보기전에 레코드 캡슐화하기 로 숨긴다.
  - 변경하면 안되는 필드는 세터제거하여 접근을 봉쇄한다.
- 상속 포기
  - 서브 클래스는 부모로부터 메서드와 데이터를 물려받는다 하지만 부모의 유산을 원치않거나 필요없다면 상속을 포기한다.
  - 메서드 내리기 와 필드내리기를 활용해서 물려받지 않을 부모코드를 모조리 새로 만든 서브클래스로 넘긴다.
  - 부모클래스는 추상클래스면 좋다.
  - 그러나 열의 아홉은 굳이 리팩토링하지 않아도 되는 부분일 것이다.
  - 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을때 심하게 난다.
    - 이럴때는 서브클래스를 위임으로 바꾸기 슈퍼클래스를 위임으로 바꾸기를 활용해서 상속 메커니즘에서 벗어나보자
- 주석
  - 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많다.
