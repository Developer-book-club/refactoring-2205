# 6장 기본적인 리팩토링

## 6-1 함수 추출하기

### 키워드

함수추출, 유효범위, 임시변수, 매개변수

### 중요문장

함수를 새로만들고 목적을 잘들어내는 이름을 붙인다("어떻게" 가 아닌 "무엇을"하는지 드러낸다)
-> 함수를 선언했을 때 선언적인 코드들만 모아져 있도록 되어있어야 하기 때문에
-> 명령적 코드는 내부 함수 안에 구현되어있다.

지역변수에 다른 값을 다시 대입하지 않을때 -> 매개변수 사용하면된다.
지역변수에 다른 값을 다시 대입 할때 -> 임시변수 사용하면된다.

지역변수가 다른 값을 다시 대입하는 경우는 또다시 두가지로 나누어지는데

1. 변수가 추출된 코드 안에서만 사용될때 -> 문장 슬라이드 하기
2. 변수가 추출된 코드 바깥에서 사용될때 -> return

값을 반환 할 변수가 여러개라면?
-> 추출할 코드를 다르게 재구성한다. ( 일반적으로 하나만 반환하게 만든다 )
-> 굳이 여러 개 반환한다면? -> 임시 변수를 질의 함수로 바꾸거나 변수를 쪼갠다.

### 내생각

여기까지 읽었을 때, 나는 마틴 파울러라는 사람은 굉장히 다양한 케이스들을 가정하고 이때는~ 이렇게 나는 하고 이때는~ 이렇게 한다. 라는 시뮬레이션을 보는 것 같이 책이 읽혀졌다.

## 6-2 함수 인라인하기

### 키워드

함수인라인,

### 중요문장

때로는 함수 본문이 이름만큼 명확한 경우도 있다.
다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임관계가 복잡하게 얽혀있으면 인라인해버린다.
다형메서드인지 확인한다.
상황이 그정도로 복잡하다면 인라인하기를 적요하면 안되기 때문이다.
단계를 잘게나눠서 다시 리팩터링한다.

### 내 생각

함수들을 위임하는 코드를 많이 좋아하지는 않는다. -> 하지만 레이어분리를 위해 꼭꼭 필요하다고 본다.
뎁스가 깊어지면 추상화된 코드만 보게되고 계속 안쪽으로 들어가야 동작하는 코드를 보게된다.
지금 와서 생각해보니 함수 네이밍을 명확하게 짓지 못해서 그 함수 내부가 궁금했던 것 같다.( 그래도 디버깅을 위해서 들어가봐야했던 날들이 많았다. )

## 6-3 변수 추출하기

### 키워드

표현식, 지역변수

### 중요문장

표현식이 너무 복잡해서 이해하기 어려울때 지역변수를 활용하면 표현식을 쪼개 관리하기 더 쉽다.
변수 추출을 고려한다고 함은 표현식에 이름을 붙이고 싶다는 뜻이다.

현재 함수안에서만 의마가 있다면 변수로 추출하는 것이 좋다.
함수를 벗어난 넓은 문맥에서 까지 의미가 있다면 함수로 추출해야한다.
표현식을 중복해서 작성하지 않도록한다.
클래스 전체 영향을 줄때 변수가 아닌 메서드로 추출한다.
여러가지를 추상화 해놓으면 쉽게 활용할수있다.

### 내 생각

영향을 끼치는 스코프에 따라서 추출하는 방법이 달라진다 (변수 / 함수 / 메서드 )

## 6-4 변수 인라인하기

### 중요문장

변수이름이 원래 표현과 다를바 없을때도 있다.

## 6-5 함수 선언 바꾸기

### 키워드

함수 이름 , 매개변수, 다른 모듈과의 결합제거

### 중요문장

함수의 연결부의 중요한 요소는 함수 이름이다.
잘못된 함수 이름을 발견하는 즉시 바꾼다.
매개변수는 함수를 사용하는 문맥을 설정한다.
매개변수와 이름 바꾸기를 모두하고 싶다면 각각 독립적으로 처리하자.

### 내 생각

함수 이름을 짓는 나만의 절대적인 룰이 몇가지 있다.

- 어떤 역할을 하는지 명시할 것 (WHAT)
- 의존성이 있다면 의존성을 명시할 것 (예를 들면 , axios 에 의존하고 있는 request 하는 함수라고 했을 때 RequestByAxios? AxiosRequest? 이렇게 지을것같다. )
- 이름은 구구절절할수록 좋다.
  다른분들의 기준도 궁금합니다

## 6-6 변수 캡슐화 하기

### 키워드

캡슐화, 접근 범위가 넓은 데이터

### 중요문장

함수는 데이터보다 다루기가 수월하다.
접근할 수 있는 범위가 넓은 데이터를 옮길때는 그 데이터로의 접근을 독점하는 함수를 만드는 식의 캡슐화
데이터에 대한 결합도를 높이는 일을 막을 수 있다.

### 내 생각

데이터 변경도 쉽고 데이터 변경이 쉽다는 것은 패키징이나 api 모듈 변화에 코드 변화가 크게 없다는 것을 의미한다고 생각한다.
recoil selector 를 이용한 api 리퀘스트 레이어

## 변수이름바꾸기

### 주요문장

함수 호출 한번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경써야한다.
기존이름응 참조하는 코드들응 새 이름이로 점진적으로 바꿀수있다

### 내생각

함수 이름에 관한 고민은 slash21의 진유림님의 발표에서도 나타난다

[토스ㅣSLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code](https://youtu.be/edWbHp_k_9Y)

## 6.8 매개변수 객체 만들기

### 키워드

적당한 데이터구조, 클래스

### 주요문장

문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상

## 6.9 여러 함수를 클래스로 묶기

### 키워드

캡슐화, 클래스, 단일 접근 원칙

### 주요문장

공통데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리를 발견하면 클래스로 묶고싶다.
프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을때는 클래스로 묶어두면 큰 도움이 된다.

### 내 생각

함수의 클로저를 이용해서 공통데이터를 캡슐화 하는 방법은? (꼭 클래스만 써야된나?)

## 6.10 여러 함수를 변환 함수로 묶기

### 키워드

변환 함수

### 주요문장

변환 함수안에서는 결과 객체를 매번 복제할 필요없이 마음껏 변경해도 된다.
정보가 사용되는 곳마다 같은 도출 로직이 반복되기도한다.
도출 작업들을 한데로 모아두길 좋아한다.
로직의 중복과 검색과 갱신을 일관된 장소에서 할 수 있다.

## 6.11 단계 쪼개기

### 주요문장

서로다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개의 모듈로 나누는 방법을 모색한다.
로직을 순차적인 단계들로 분리해도 된다.
한번에 한가지 대상만 다루고, 각각을 모듈로 쪼개라
가령 컴파일러에서 렉서와 파서를 쪼개는 것 처럼.
즉 서로 다른 단계로 쪼개고, 각각의 단계에서는 자기 단계의 일만 신경쓴다.
priceOrder.mjs에 작성

# 10장 조건부 로직 간소화

## 10.1 조건문 분해하기

### 키워드

복잡한 조건부 로직

### 주요문장

덩어리의 의도를 살린 함수의 호출로 바꿔주자
해당 조건이 무엇인지 강조하고 그래서 무엇을 분기했는지 명백해진다.

## 10.2 조건식 통합하기

### 키워드

비교하는 조건은 다르지만 수행하는 동작이 똑같은 코드

### 주요문장

조건부 코드를 통합하는게 중요한 이유는 두가지다.
여러조각으로 나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다.
이 작업이 함수 추출하기로 이어질 가능성이 높다.
if 두개 중첩되면 and, 여려 조건이 같은 로직을 수행하면 or 로 바꾼다.

## 10.3 중첩 조건문을 보호 구문으로 바꾸기

### 키워드

보호 구문

### 주요문장

조건문은 주로 두가지 형태로 쓰인다. 참과 거짓 경로 모두 정상동작하는경우 if else
한쪽만 정상인 경우 if return (early return)
코드에서 반환점이 하나일 때 함수 로직이 명백하다면 그렇게하자.

### 내생각

early return 을 애용하는데 else 로 명시하는게 좋을까? 아니면 switch 의 default 값처럼 else 의 로직을 맨 아래 선언하는게 좋을까?

### 10.4 조건부 로직을 다형성으로 바꾸기

### 키워드

클래스, 다형성

### 주요문장

case 별로 클래스를 하나씩 만들어 공통 switch 로직의 중복을 없앨수 있다.
실제로 모든 조건부 로직을 다형성으로 대체해야한다고 주장하는 사람도 만난적있다.
조건부 로직은 대부분 if/else switch/case 로 이루어져있다.
객체가 적절한 이름의 메서드만 구현하고 있다면 같은 타입으로 취급하기 때문이다. (덕타이핑)

### 10.5 특이 케이스 추가하기

### 키워드

특이 케이스, null

### 주요문장

특정 값에 대해 똑같이 반응하는 코드가 여러곳이라면 그 반응들을 한데 모으는게 효율적이다.
큭이 케이스 객체에서 단순히 데이터를 읽기만 한다면 반환할 값들을 담은 리터럴 객체 형태로 준비하면된다.

겉보기 동작을 똑같게 만들어야하므로 -> (왜??)
리터럴을 이런 식으로 사용하려면 불변으로 만들어야한다(freeze)
