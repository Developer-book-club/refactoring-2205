# CH.07 캡슐화

# 7.1 레코드 캡슐화하기

## 중요 내용

- 가변 데이터를 저장하는 용도로는 레코드 보다 객체를 선호하는 편이다.
- 객체를 사용하면 어떻게 저장했는지를 숨긴채 세가지 값을 각각의 메서드로 제공할 수 있다.

## 내 생각

- 중첩 정도가 심할 수록 읽거나 쓸때 데이터 구조안으로 더 깊숙히 들어가야한다라는 예시 덕분에 캡슐화를 해서 set 이나 get 을 하는게 코드를 더 읽기 쉽게 만드는 구나 라는 생각을 했다.

# 7.2 컬렉션 캡슐화하기

## 중요 내용

- 컬렉션 변수로의 접근을 캡슐화하면서 케터가 컬렉션 자체를 반환하도록하면 컬렉션을 감싼 클래스가 눈치 못채는 상황에서 원소들이 바뀔수있다.
- 가장 흔히 사용하는 방식은 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.
- 세터를 이용해 수업 컬렉션을 통채로 설정한 클라이언트는 누구든 이 컬렉션을 마음대로 수정할 수있다.

## 내 생각

- 원본 컬렉션을 반환하는게 컬렉션을 바꿀 위험을 높이는 것인가?

# 7.3 기본형을 객체로 바꾸기

## 중요 내용

- 나는 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다.
- 나중에 특별한 동작이 필요해지면 이 클래스에 추가하면 되니 프로그램이 커질수록 점점 유용해진다.

## 내 생각

# 7.4 임시 변수를 질의 함수로 바꾸기

## 중요 내용

- 함수 안에서 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 한다. 한 걸음더 나아가 함수로 만들어 사용한다.
- 변수는 값을 한번만 계산하고 그 뒤로는 읽기만해야한다.

# 7.5 클래스 추출하기

## 중요 내용

- 메서드와 데이터가 너무 많은 클래스는 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.
- 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다.
- 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다
- 확장해야할 기능이 무엇이냐에 따라서 서브클래스를 만드는 방식이 달라진다면 클래스를 나눠야한다.

# 7.6 클래스 인라인하기

## 중요 내용

- 두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인 한다.
- 클래스의 역할이 거의 없을때 이런현상이 자주 생긴다.

# 7.7 위임 숨기기

## 중요 내용

- 서버 객체의 필드가 가리키는 객체의 메서드르르 호출하려면 클라이언트는 이 위임 객체를 알아야 한다. 위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야 한다. 이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.
- 위임 객체가 수정되더라도 서버 코드만 고치면 되며, 클라이언트는 아무런 영향을 받지 않는다.

# 7.8 중개자 제거하기

## 중요 내용

- 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버의 위임 메서드를 추가해야 하는데 ,이렇게 기능을 추가하다 보면 단순히 전달만 하는 위임 메서드들이 점점 성가셔진다.
- 어느정도 까지 숨겨야 적절한지 판단하기란 쉽지 않지만, 우리에게는 다행히 위임 숨기기와 중개자 제거하기 리팩터링이 있으니 크게 문제는 되지는 않는다.

# 7.9 알고리즘 교체하기

## 중요 내용

- 나는 더 간명한 방법을 찾아내면 복잡한 기존 코드를 간명한 방식으로 고친다.

## 전반적인 내 생각과 의문

- 내가 만들었던 리액트 프레임 워크에서 클래스를 적극적으로 사용하지 않았다. 그치만 캡슐화는 클래스 뿐아니라 클로저를 이용해서 또한 할 수있는 작업이므로 앞으로 코드를 짤때 염두해 두고 짜야겠다.
