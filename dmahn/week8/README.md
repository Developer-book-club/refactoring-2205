# chapter 12 상속 다루기

상속은 왜 쓸까 -> 코드를 재사용하기 위해

상속할때 주의점(문제점)

- 딱하나만 상속이 가능함
- 불필요한 기능이 상속됨
- 족보가 꼬일수 있음
- 수정이 어려움

상속보다는 컴포지션을 선호하자

컴포지션은 => 위임 / 가지다.

## 메서드 올리기

### 요약

- 동일한 로직의 메서드들이 하위 클래스에서 동일하게 적용된다면 상위 클래스로 올린다.

## 필드 올리기

### 요약

- 공통된 필드를 하위 클래스에서 동일하게 적용된다면 상위 클래스로 올린다.

### 내 생각

- 내가 어떤 메서드, 필드들을 가지고 만들건지 먼저 설계하고 (그치만 한번에 완벽하게 짜지는 않고) 나중에 수정해보는 연습이 필요할 것 같다.

## 생성자 본문 올리기

### 요약

- 공통된 생성자 함수의 로직이 하위 클래스에서 동일하게 적용된다면 상위 클래스로 올린다.

## 메서드 내리기

### 요약

- 특정한 하위 클래스에서만 사용되는 메서드는 하위 클래스로 내린다.
- 코드를 이용할때 이야하기 어렵기 때문

## 필드 내리기

### 요약

- 특정한 하위 클래스에서만 사용되는 필드는 하위 클래스로 내린다.

## 타입 코드를 서브클래스로 바꾸기

### 요약

- 외부에서 type 이라는 flag 를 전달 받아서
- 생성자에서 에러를 던지는 것 나쁨 (validate 를 생성자안에서 할 필요없이 만든다.)

## 서브클래스를 제거하기

- 앞에 챕터와 완전 반대

## 위임 알아보기

- 상속과 위임의 차이
  // 상속

```
class Printer {
    print () {}
}

class RedPrinter extends Printer{

}
```

그러나 다중 상속이 되지 않는다.

```
class Printer {
    #printerDelegate;
    constructor () {
        this.#printerDelegate = new PrinterDelegate();
    }
    print () {
        this.printerDelegate? this.printerDelegate.print() : console.log("print");
    }
}

class RedPrinter {
    print() {
        console.log("redPrinter)
    }
}

new Printer(new RedPrinter()).print();

```

## 서브클래스를 위임으로 바꾸기

가장 명확한 단점은 한번만 쓸수있는 카드라는 것이다.
부모를 수정하면 이미 존재하는 자식들의 기능을 해치기 가 쉽기 때문에 조심해야한다.

위임은 상속보다 결합도가 약하고
상속보다는 컴포지션을 사용하라

내생각

- delegate 는 외부로 부터 주입받을 수 있게 만드는 것이 좋지 안을까?

## 12.11 슈퍼클래스를 위임으로 바꾸기

상속을 하면 불필요한 메서드들도 상속 받을 수 있다.
재활용하겟다는 생각이 초래한 결과다.
재활용 관점에서는 좋았지만 이 상속에는 문제가 있다. 리스트 연산중 스택에는 적요오디지 않은게 많음에도 그 모든연산이 스택 인터페이스에 그대로 노출된다는 것이다.
이보다는 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 좋다.
왠만하면 상속을 먼저 적용하고 나중에 문제가 생기면 슈퍼클래스를 위임으로 바꾸라는 것이다.
